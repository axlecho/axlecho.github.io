<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2020年度总结]]></title>
    <url>%2F2020%2F01%2F09%2F%E8%AE%B0%E4%BA%8B%2F2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[记些2019的流水账及一些人生感悟 到杭州前的记录貌似被自己全清掉了 1月博客搬家，一开始是在新浪云，之后搬到了DataOceans，丢失了一部分图片，再之后搬到了Github，丢失了所有日志的日期信息 3月搬到杭州 4月开始投资股票 王者荣耀打到了王者段位 沉迷了一段时间手机游戏《召唤与合成》 6月买了一个空调遥控器 股票大亏（最高一千多） 看到一只猫在车顶 尝试推广JtsViewer 沉迷手机游戏《明日方舟》 7月整了一个《明日方舟》手机主题 沉迷一段时间的手机游戏《皇家骑士》（300自走棋） MHViewer被检测为病毒 8月加入了中年择业群 更换了微信头像 在找工作中 到《杭州做客文化传媒有限公司》工作 9月沉迷《明日方舟》活动 沉迷《崩坏3》手机游戏 貌似有经历了几把台风 10月感冒过后的一天被离职了 沉迷游戏《战争艺术》 — 画风很好游戏，那时对自走棋有点失去兴趣了 11月买了个空调 12月沉迷游戏《战双帕弥什》 参加了跨年晚会]]></content>
      <categories>
        <category>记事</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[aidl的使用]]></title>
    <url>%2F2019%2F11%2F07%2FAndroid%2FAndroid%E9%97%AE%E9%A2%98%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[梳理一些常见的题目 android 跨进程通信]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人简历]]></title>
    <url>%2F2019%2F10%2F17%2F%E7%9B%AE%E6%A0%87%2F%E7%AE%80%E5%8E%86%2F</url>
    <content type="text"><![CDATA[个人信息姓名: 陈益煌性别: 男出生: 1992.04邮箱: axlecho@gmail.com电话: 13025231625github: https://github.com/axlecho 教育经历西安电子科技大学 本科(2011.9-2015.6)通信工程 信息安全专业 掌握技能熟练掌握Java、Kotlin开发,对Android框架底层有深刻了解熟练掌握UI控件特性,手势,能实现复杂界面布局及视觉效果熟悉Linux开发环境,掌握编写shell脚本熟悉Git版本控制工具熟悉Rxjava,Robolectric等框架了解Javascript前端技术 工作经历杭州作客文化传媒有限公司主要产品有作客文学网及对于移动端app，主要工作为维护Android版本客户端 职位：Android工程师 负责小说阅读器开发与完善 推广工具开发 购大大科技有限公司(2017.09 - 2019.02)一家新兴的创业公司，实现一个集购物，直播和短视频为一体的网站及App主要工作为Android客户端的研发，后期也负责一部分的后台开发 职位: Android工程师负责客户端的开发,服务端的后台开发 实现了视频上传,剪辑,播放功能,实现了自定义的带弹幕系统的视频播放器 实现了支付系统 账号系统(注册,登录,验证码等) 后台开发采用了Thinkphp架构 实现了数据管理系统 简单的实时聊天室系统 直播系统 万普拉斯科技有限公司(2015.10 - 2017.06)旗下品牌有一加手机等 参与一加三与一加五项目的研发及维护，主要负责音视频模块和NFC模块职位: Android Framework工程师音视频模块主要为优化系统运行速度,优化音质等 完成了音频控制的三段式开关的实现与优化,可用硬件控制场景模式 研发出来一套自动测试滑动性流畅度的工具 NFC模块主要是NFC金融方面的工作 参与完成了手机刷卡应用”一加钱包”,可代替公交刷卡及地铁刷卡,主要负责NFC底层参数调试 负责NFC银联认证及处理NFC相关问题(Android Pay及银联app等) 百度(2014.08 - 2014.10)职位：Android工程师(实习) 在基础架构部任职,维护开发者平台的一些组件(增量更新sdk,推送消息等)引进了新的diff工具Courgette,大大减小了增量包体积 个人项目JtsViewer个人业余的开源项目,一款Android平台上的吉他谱阅读器app,可用于播放GTP格式的吉他谱,还有吉他相关的功能如节拍器及调音器等完成了登录,搜索,收藏,评论等普通功能,移植TuxGuitar以支持GTP MHViewer个人业余的开源项目,一款Android平台上的漫画阅读器app,有国内大型漫画网站源完成了对各个网站源的解析,使用Rhino进行网页前端解密,移植libwebp以对webp图片的支持 使用的技术点 网络请求: Retroft + RxJava 网页解析: Jsoup,正则表达式 数据库: GreenDao 图片显示: 使用Native Heap的图片库 – Image@seven332 其他爱好软件(游戏)破解吉他演奏]]></content>
      <categories>
        <category>目标</category>
      </categories>
      <tags>
        <tag>目标</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F10%2F15%2FAndroid%2F%E6%B8%B8%E6%88%8FMod%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[游戏Mod制作本想写个明日方舟Mod教程，结果目标加壳了，算了算了 游戏Mod就是在原有的游戏上修改部分功能的修改版游戏，一般体现为修改攻击力，HP等现在的游戏大部分基于Unity 3D的引擎开发，其逻辑实现全都集中在libil2cpp.so上，因此只需修改该库便可实现效果 准备阶段那让我们开始吧 目标这里我们选明日方舟这款游戏，因为弱联网的缘故，反破解手段用得比较少（是根本没有）下载目标apk并解压出libil2cpp.so及global-metadata.dat 工具准备Il2CppDumper用于反编译global-metadata.dat的符号表及生成libil2cpp.so的符号加载脚本此工具为开源工具github IDA用于反汇编libil2cpp.so，主要的修改工作用于此 jarsigner用于重新签名apk，安装JDK便可得到该工具 反编译打开Il2CppDumper，第一次选libil2cpp.so， 再选global-metadata.dat 模式我们选Auto(Plus)]]></content>
  </entry>
  <entry>
    <title><![CDATA[习惯]]></title>
    <url>%2F2019%2F07%2F22%2F%E7%9B%AE%E6%A0%87%2F%E4%B9%A0%E6%83%AF%2F</url>
    <content type="text"><![CDATA[一次只做一件事 不要在房间里抽烟 多喝水]]></content>
      <categories>
        <category>目标</category>
      </categories>
      <tags>
        <tag>目标</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[明日方舟]]></title>
    <url>%2F2019%2F07%2F14%2F%E6%B8%B8%E6%88%8F%2F%E6%98%8E%E6%97%A5%E6%96%B9%E8%88%9F%2F</url>
    <content type="text"><![CDATA[最近还在玩的两款游戏之一 王者荣耀花费精力太大，不得不戒了，没游戏玩总觉得有点无聊 逛TAPTAP的时候看到热版第一的游戏，塔防 + 养成，可以啊，这不就是我理想中的游戏吗 其实第一次接触舟游还在二测的时候，在还是训练关时候，看到贴图有些廉价，连主界面都没进去就卸载了 当时是晚上下的，觉得主界面挺有科技感的，关卡也挺有趣，一玩就玩到早上，不过跟植物大战僵尸一样，没几天主线就通关了问题就是体力没多少，一天打没半小时就没事干了，就只是逛论坛跟别人嘴，不过也没多大意思 不过游戏本身包括界面，立绘，可玩性都还可以，在各个平台下载量热度都很高 一开始抽了3个6星，后面又出了两重复，果然非洲人 黑心老板上线，派些手下做这做那的，没事就割割韭菜 花了600合成玉买的简历，简历都是用包包的。。。 怎么又是你！！ 没事干就只能刷钱刷材料，跟阴阳师一个德行 玩到后面没啥可玩的，就无聊的刷起小号，有3个6星开局，羊，星熊，小火龙小火龙那个号玩了还有一段时间，不过两个号切换实在麻烦，就删掉了。 后来又在BiliBili服搞了新号，简直就是非洲偷渡过来的，一开始只有系统送的5星，到现在两6星都是保底出的。当然这么非的号，只能靠科技来拯救。]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>塔防</tag>
        <tag>养成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android总结]]></title>
    <url>%2F2019%2F07%2F09%2FAndroid%2FAndroid%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Android的一些基础总结 ActivityActivity的生命周期onCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestroy↑ || ↓onRestart 各种场景流程第一次启动 onCreate -&gt; onStart -&gt; onResume打开新Activity onPause(A) -&gt; onCreate(B) -&gt; onStart(B) -&gt; onResume(B) -&gt; onStop(A)按back返回原来的Activity onPause(B) onRestart(A)-&gt; -&gt; onStart(A) -&gt; onResume(A) -&gt; onStop(B) -&gt; onDestory(B)按home键 onPause -&gt; onStop -&gt; onRestart -&gt; onStart -&gt; onResumefinish onDestory 横竖屏切换onStop之前 onSaveInstanceState &amp;&amp; onStart之后 onRestoreInstanceStateonPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestory -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume避免横竖屏切换销毁activity123456android:configChanges = "orientation\| screenSize" @Overridepublic void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig);&#125; activity优先级前台activity Resumed（活动状态）可见activity Paused（暂停状态）后台activity Stopped（停止状态） 启动模式标准模式（standard）栈顶复用模式（singleTop）栈内复用模式（singleTask）单例模式（singleInstance） singleTop 防重复点击，通知栏 1234@Overrideprotected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent);&#125; singleTask 单例模式的activity 主界面singleInstance 单例模式的activity加强版 桌面启动，呼叫来电 特殊情况：调用SingleTask模式的后台任务栈中的Activity，会把整个栈的Actvity压入当前栈的栈顶。singleTask会具有clearTop特性，把之上的栈内Activity清除。 Activity flagsFLAG_ACTIVITY_NEW_TASKFLAG_ACTIVITY_SINGLE_TOPFLAG_ACTIVITY_CLEAR_TOP BroadcastReceiver模型：观察者模式订阅者 - 发布者 - 消息中心 AM 静态注册 在AndroidMainifest.mxl首次启动app，会实例化该广播并注册到系统动态注册 使用Context的registerReceiver动态广播 注册必须注销，不然会有内存泄漏 广播种类普通广播系统广播有序广播应用内广播(exported = false，permission，setPackage) ContentProvider数据交互与共享 ContentProvider的使用 统一资源识别符 schema:authorith:path:idmime /表数据增、删、查、改ContentResolver - cursorContentUrisUriMatcherContentObserver 123&lt;provider android:name="MyProvider" android:authorities="cn.scu.myprovider"/&gt; 优点:安全、访问简单&amp;高效，(数据源的adapter) 消息机制流程Message – MessageQueue – Handler –Looperhandler.sendMessage –&gt; MessageQueue -&gt; Looper.loop(Message.next) –&gt; handler.dispatchMessage -&gt; handler.handleMessagelooper – Looper.prepare – Looper.loophandler – (post &amp;&amp; send)sendMessageAtTime – MessageQueue.enqueueMessage – MessageQueue.next – handler.dispatchMessage 事件分发机制分发MotionEvent 流程驱动捕获 -&gt; Activity（Window） -&gt; ViewGroup -&gt; ViewdispatchTouchEvent() – onInterceptTouchEvent – onTouchEvent() return true(消费该事件) false (拦截消息) super 默认情况dispatchTouchEvent:activity -&gt; viewgroup -&gt; viewonTouchEvent:view -&gt; viewgroup -&gt; activityviewgroup重载onInterceptTouchEvent() 并返回true，事件不再传递到view调用onTouch,activity不再处理事件 View消费事件的条件enableonTouch 返回trueonTouch 高于onClick 事件的连锁机制ACTION_DWON return true后，ACTION_UP与ACTION_MOVE才能收到onInterceptTouchEvent 异步AsyncTask其实是个线程池 实现:SerialExecutor，THREAD_POOL_EXECUTOR，InternalHandler 核心方法onPreExecute() // 主线程doInBackgroud() // 子线程onProgressUpdate(Progress…) // 主线程onPostExecute(Result) // 主线程onPreExecute() –&gt; doInBackground() –&gt; publishProgress() –&gt; onProgressUpdate() –&gt; onPostExecute()cancel 设置cancel标记位note:InternalHandler是一个静态类，为了能够将执行环境切换到主线程，因此这个类必须在主线程中进行加载。所以变相要求AsyncTask的类必须在主线程中进行加载。 note:使用不当会引起不良后果例如在生命周期onDestroy内调用cancel 会造成内存泄漏、结果丢失 跨进程Android跨进程形式Activity隐式启动Content providerBroadcastRemote Service(startService、AIDL） Binder有什么优点高效、安全（Uid鉴权）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>技术总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[privacy_policy]]></title>
    <url>%2F2019%2F05%2F09%2FAndroid%2FJtsViewer%2F</url>
    <content type="text"><![CDATA[Privacy PolicyAxlecho built the JtsViewer app as an Open Source app. This SERVICE is provided by Axlecho at no cost and is intended for use as is. This page is used to inform visitors regarding my policies with the collection, use, and disclosure of Personal Information if anyone decided to use my Service. If you choose to use my Service, then you agree to the collection and use of information in relation to this policy. The Personal Information that I collect is used for providing and improving the Service. I will not use or share your information with anyone except as described in this Privacy Policy. The terms used in this Privacy Policy have the same meanings as in our Terms and Conditions, which is accessible at JtsViewer unless otherwise defined in this Privacy Policy. Information Collection and Use For a better experience, while using our Service, I may require you to provide us with certain personally identifiable information. The information that I request will be retained on your device and is not collected by me in any way. The app does use third party services that may collect information used to identify you. Link to privacy policy of third party service providers used by the app Google Play Services Log Data I want to inform you that whenever you use my Service, in a case of an error in the app I collect data and information (through third party products) on your phone called Log Data. This Log Data may include information such as your device Internet Protocol (“IP”) address, device name, operating system version, the configuration of the app when utilizing my Service, the time and date of your use of the Service, and other statistics. Cookies Cookies are files with a small amount of data that are commonly used as anonymous unique identifiers. These are sent to your browser from the websites that you visit and are stored on your device’s internal memory. This Service does not use these “cookies” explicitly. However, the app may use third party code and libraries that use “cookies” to collect information and improve their services. You have the option to either accept or refuse these cookies and know when a cookie is being sent to your device. If you choose to refuse our cookies, you may not be able to use some portions of this Service. Service Providers I may employ third-party companies and individuals due to the following reasons: To facilitate our Service; To provide the Service on our behalf; To perform Service-related services; or To assist us in analyzing how our Service is used. I want to inform users of this Service that these third parties have access to your Personal Information. The reason is to perform the tasks assigned to them on our behalf. However, they are obligated not to disclose or use the information for any other purpose. Security I value your trust in providing us your Personal Information, thus we are striving to use commercially acceptable means of protecting it. But remember that no method of transmission over the internet, or method of electronic storage is 100% secure and reliable, and I cannot guarantee its absolute security. Links to Other Sites This Service may contain links to other sites. If you click on a third-party link, you will be directed to that site. Note that these external sites are not operated by me. Therefore, I strongly advise you to review the Privacy Policy of these websites. I have no control over and assume no responsibility for the content, privacy policies, or practices of any third-party sites or services. Children’s Privacy These Services do not address anyone under the age of 13. I do not knowingly collect personally identifiable information from children under 13. In the case I discover that a child under 13 has provided me with personal information, I immediately delete this from our servers. If you are a parent or guardian and you are aware that your child has provided us with personal information, please contact me so that I will be able to do necessary actions. Changes to This Privacy Policy I may update our Privacy Policy from time to time. Thus, you are advised to review this page periodically for any changes. I will notify you of any changes by posting the new Privacy Policy on this page. These changes are effective immediately after they are posted on this page. Microphone usage This application records sound through the device on which it is installed microphone. Sound that is recorded is not collected or send through the internet. It is used only for the purpose of providing information to the user to help him tune his musical instrument. Contact Us If you have any questions or suggestions about my Privacy Policy, do not hesitate to contact me at axlecho@gmail.com. This privacy policy page was created at privacypolicytemplate.net and modified/generated by App Privacy Policy Generator]]></content>
      <tags>
        <tag>JtsViewer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题]]></title>
    <url>%2F2019%2F04%2F11%2FJava%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[准备个底在去受虐 Java 基础JDK和JRE有什么区别？jdk是开发包，jre是运行环境JDK是Java的开发工具，它不仅提供了Java程序运行所需的JRE，还提供了一系列的编译，运行等工具，如javac，java，javaw等。JRE只是Java程序的运行环境，它最核心的内容就是JVM（Java虚拟机）及核心类库。 ==和equals的区别是什么？==比较的是对象，equals比较多是对象的内容从原理来讲，Object的equals是由 == 实现的，讨论的比较多的String是重载了Object的equals改变了比较的方式 两个对象的hashCode()相同，则equal()也一定为true，对吗？equal相等的 hashcode一定相等 反过来hashcode不相等的equal一定不相等hashcode相等的不一定equal相等(md5) final在Java中有什么作用？对象修饰，一旦赋值不可修改类修饰，不可继承方法修饰，不可重载 Java中的Math.round(-1.5)等于多少？a + 1/2 向下取整-1.5 + 0.5 = -1.0a + 1/2是用位操作完成的 String属于基础的数据类型吗？不是，final类stort long int double float byte char boolean Java中操作字符串都有哪些类？他们之间有什么区别？正则表达式 String str=”i” 与 String str = new String(“i”)一样吗？否，”i”在常量池，new String(“i”)在堆上 如何将字符串反转？StringBuffer reverse 中间对调 &gt;&gt; String类的常用方法都有哪些？length()charAt()substring()replace()indexOf()trim()split() 抽象类必须要有抽象方法吗？可以没有抽象方法 普通类和抽象类有哪些区别？抽象类不能直接使用，只能通过子类实现其所有抽象方法后才能使用 抽象类能使用final修饰吗？不能 内部可以为private 接口和抽象类有什么区别？方法均为public abstract成员均为public static final接口不可有构造方法 抽象类可以有实现方法，接口的不能有实现类只能继承一个父类，但可以实现多个接口 Java中IO流分为几种流向： input output类型：字节流 字符流节点流 处理流 缓冲流 BIO、NIO、AIO有什么区别Block IO、Non-Blocking IO、Ansyc IO Files的常用方法都有哪些new FilemkdirmkdirsrenameTo deleteexistsisFileisDirectory getNamegetAbsolutePathlength listlistFiles 容器java容器都有哪些？Collection List ArrayList (数组) LinkedList(双向链表) Set HashSet(HashMap实现) TreeSet(TreeMap实现) LinkedHashSet(LinkedHashMap实现) Queue PriorityQueue Map HashMap(单链表数组) LinkedHashMap(有序Map HashMap + 双向链表) TreeMap Iterator ListIterator Comparable &amp; Comparator Utilities Collections Arrays Collection和Collections有什么区别Collections为工具类Collection为集合接口 List、Set、Map之间的区别是什么列表有序，Set为Value唯一，Map为key索引 HashMap和Hashtable有什么区别线程安全 null-key &amp; null-value迭代器 如何决定使用HashMap还是TreeMapHashMap 查询TreeMap 增加、快速创建 说下HashMap的实现原理数组加列表，拉链法，加载因子、扩容 说下HashSet的实现原理使用HashMap实现 ArrayList和LinkedList的区别？ArrayList使用数组实现，查询O(1),增加O(1)，删除O(n)LinkedList使用链表实现，查询O(n)，增加O(1)，删除O(1） 如何实现数组和List之间的转换？toArray()new Array() == Arrays.asList();new List() + addlist ArrrayList和Vector的区别？Vector是线程安全 Queue中poll() 和remove()有什么区别当Queue为空的处理方式不一样 哪些集合类是线程安全的HashTable Vector 迭代器Iterator是什么？一个接口 hasNext next remove Iterator怎么使用，有什么特点统一了遍历方式 Iterator和ListIterator有什么区别索引，add，逆向遍历，set 怎么确保一个集合不能被修改Collections.unmodifiableMap 多线程并行和并发有什么区别？并发cpu切换并行cpu运行不同任务 线程和进程的区别？进程——资源分配的最小单位，线程——程序执行的最小单位。 内容空间:共享相同数据段，有相同的地址空间通信方式:管道，信号，消息队列，共享内存，套接字共享资源:文件描述符等 优缺点：线程轻量 进程稳定安全 守护线程是什么GC线程，当所有的User Thread都退出时，守护线程会自动退出 说一下runnable和callable有什么区别Runnable没有返回值；Callable可以返回执行结果Callable接口的call()方法允许抛出异常；Runnable的run()方法异常只能在内部消化，不能往上继续抛 线程有哪些状态1.新建状态2.就绪状态等待CPU时间3.运行状态4.阻塞状态sleep - IO - 获取锁 - wait()5.死亡状态正常运行，抛出异常 isAlive() sleep()和wait()有什么区别？ sleep()是Thread wait()是Object wait阻塞当前线程，会释放synchronized的锁， notify()和notifyAll()有什么区别? notify会释放一个wait的锁 notifyAll会释放所有wait的锁，并开始竞争 创建线程池有哪几种方式？newSingleThreadExecutornewFixedThreadPoolnewCachedThreadPoolnewScheduledThreadPool 线程池都有哪些状态?running -&gt; shutdown -&gt; stop -&gt; tidying -&gt; terminated 线程池中submit() 和execute()方法有什么区别?submit 有返回值，便于处理异常 在Java程序中怎么保证多线程的运行安全? 原子性 atomic,synchronized 可见性 synchronized,volatile 有序性 synchronized,LOCK 多线程锁定升级原理是什么？偏向锁 没有竞争线程轻量级锁 有一个竞争线程重量级锁 有两个以上竞争线程 什么是死锁？互斥条件请求和保持条件不剥夺条件循环等待条件 怎么防止死锁？加锁时许超时死锁检测 ThreadLocal是什么？有哪些使用场景？说一下Synchronized底层实现原理？监视器锁计数 进入+1，释放-1ACC_SYNCHRONIZED Synchronized 和 volatile的区别是什么？ volatile关键字解决的是内存可见性的问题 synchronized关键字解决的是执行控制的问题 volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。 volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的 volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性 volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。 volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化 Synchronized 和 Lock有什么区别？ synchronized是java内置关键字，在jvm层面，Lock是个java类 synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁 synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了 synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可） Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。 Synchronized 和 ReentrantLock区别是什么？说一下Atomic的原理volatile保证可见性自旋 + CAS（乐观锁）保证原子性 反射什么是反射？反射机制指的是程序在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。 什么是Java序列化？什么情况下需要序列化？Java Serialization、Json、Hession、Dubbo、FST、Kryo将对象的内容进行流化 动态代理是什么？有哪些应用？动态代理是一种在运行时动态地创建代理对象，动态地处理代理方法调用的机制日志处理注释性能 怎么实现动态代理？InvocationHandlernewProxyInstancemethod.invoke(hello, args); 对象拷贝为什么要使用克隆？想对一个对象进行处理，又想保留原有的数据进行接下来的操作 如何实现对象克隆？=cloneCloneable序列化 深拷贝和浅拷贝区别是什么？clong应用及clone值 异常throw和throws的区别？throws声明会抛出的异常，throw抛出具体异常 final和finally、finalize有什么区别？finalize GC相关 try-catch-finall中哪个部分可以省略？catch 或 finally 可以省略一个 try-catch-finally中，如果catch中return了，final还会执行吗？final会执行，return为final中的为准 常见的异常类有哪些？IOException RunntimeException NullPointerException 、 IllegalArgumentException、ClassNotFoundException、ArithmeticException、ArrayIndexOUtOfBoundsException、InputMisMatchException、NumberFormatException JVM说一下JVM的主要组成部分？及其作用？类加载子系统方法区 java堆 直接内存垃圾回收系统java栈 每个线程均有一个栈本地方法栈PC寄存器 指向当前命令执行引擎https://www.cnblogs.com/zwbg/p/6194470.html 说一下JVM运行时数据区？程序计数器 虚拟机栈 本地方法栈 堆 方法区（常量，静态变量） 说一下堆栈的区别？堆是一种排过序的树形数据结构栈是一种后进先出性质的数据结构 队列和栈是什么？有什么区别？什么是双亲委派模型？说一下类加载的执行过程？怎么判断对象是否可以被回收？java 中都有哪些引用类型？说一下JVM有哪些垃圾回收算法？说一下JVM有哪些垃圾回收器？详细介绍一下CMS垃圾回收器？新生代垃圾回收器和老生带垃圾回收器都有哪些？简述垃圾回收器是怎么工作的？说一下JVM调优的工具？常用的JVM调优的参数都有哪些？]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初到杭州]]></title>
    <url>%2F2019%2F04%2F09%2F%E8%AE%B0%E4%BA%8B%2F%E5%88%9D%E5%88%B0%E6%9D%AD%E5%B7%9E%2F</url>
    <content type="text"><![CDATA[2019年3月26日 终于鼓起勇气跑路了，其实在去年双12的时候就放弃了电商这条路，但想着要等过年吧，想着要等二十六吧，想着要等老二安顿好了再走，拖着拖着就到3月末咯 在7天酒店住了三天，天天下雨，找房子，结果58上大多数都是骗子，打电话问，结果说要到中介总部去才能带去看房，我信你个鬼哦，有一次一个中介离酒店比较近，就顺路去看什么情况，结果要先交钱，还要签协议，这不明摆骗人么 过滤了下安选房源，倒是都是真的，不过又么就是老旧破，又么就是隔断的，跑了两天决定换个网上推荐的贝壳网只看了两处，感觉都还不错，特别是现在住的地方，主要是够明亮 过来后，就去买了各种东西，感觉还好没买到糟心的东西，特别是这张圆脚桌子，超级喜欢，就是物流慢 之后就颓，花了三天把王者荣耀上来王者段位，然后还是各种颓每天3点后睡觉，第二天下午2点起床，还好感觉身体还没问题，慢慢改变吧唉 好好找工作，让家里人别太担心了]]></content>
      <categories>
        <category>记事</category>
      </categories>
      <tags>
        <tag>开始</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好多蚊子]]></title>
    <url>%2F2019%2F03%2F06%2F%E8%AE%B0%E4%BA%8B%2F%E5%A5%BD%E5%A4%9A%E8%9A%8A%E5%AD%90%2F</url>
    <content type="text"><![CDATA[又到了一年春季了是该重新出发了]]></content>
      <categories>
        <category>记事</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近况]]></title>
    <url>%2F2019%2F02%2F11%2F%E8%AE%B0%E4%BA%8B%2F%E8%BF%91%E5%86%B5%2F</url>
    <content type="text"><![CDATA[身体变得很糟糕精神变得很糟糕 很久没写博客了，转行穷3年，我才半年，加油，做写程序最吊的生意人]]></content>
      <categories>
        <category>记事</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恶之华]]></title>
    <url>%2F2019%2F02%2F11%2F%E5%8A%A8%E6%BC%AB%2F%E6%81%B6%E4%B9%8B%E5%8D%8E%2F</url>
    <content type="text"><![CDATA[蛤，无聊的世界]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[又一年]]></title>
    <url>%2F2019%2F02%2F11%2F%E8%AE%B0%E4%BA%8B%2F%E5%8F%88%E4%B8%80%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[生日悄悄的过去了，最惦记我的还是招行，中国联通 - -。。无太所谓了，阴阳师弃掉，JtsViewer捡起来，生意要学着做，已经没有退路了]]></content>
      <categories>
        <category>记事</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[突发奇想]]></title>
    <url>%2F2019%2F02%2F11%2F%E6%97%A0%E7%97%85%E5%91%BB%E5%90%9F%2F%E6%97%A5%E5%B8%B8%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[不能决定自己的命运，总有选择命运的权利吧]]></content>
      <categories>
        <category>无病呻吟</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今年最后一次绝望]]></title>
    <url>%2F2019%2F02%2F11%2F%E6%97%A0%E7%97%85%E5%91%BB%E5%90%9F%2F%E4%BB%8A%E5%B9%B4%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E7%BB%9D%E6%9C%9B%2F</url>
    <content type="text"><![CDATA[新年快到啦，打扫下卫生，起床吃饭刷牙洗脸，困得很 昨天刚看完终末少女旅行，到了最上层什么都没有，坐着等死，真让人羡慕呢。 （名为旅行 读做绝望） 过几天就要去辞职，后续的人生扑所迷离，自己要多保重自己了，不能太任性 昨天呐，半夜突然发现自己在做梦，到处黑乎乎的一片，挺吓的，那时候就在想，植物人是不是就是这个样子呢，想努力睁开眼睛，却发现醒不过来，心想着完蛋了，要变植物人了，想扭一扭唤醒自己，发现自己动不了，慌了。。。（不过待会自己就睁开眼睛，怕得要死瞪了好一会天花板，最终敌不过睡意又睡死过去了） 植物人能不能听到别人说话呢，会不会做梦呢，很好奇呢。。。]]></content>
      <categories>
        <category>无病呻吟</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Monster]]></title>
    <url>%2F2019%2F02%2F11%2F%E6%97%A0%E7%97%85%E5%91%BB%E5%90%9F%2FMonster%2F</url>
    <content type="text"><![CDATA[最近刷牙老是干呕，烟确实得戒了。。 回来后发现，小伙伴们都出去了，哎，那我回来干嘛 感觉女朋友好麻烦（结婚也好麻烦。。）要能直接有个女儿就好了 最讨厌冬天的雨，又冷又湿，这种天气快快过去吧 还是习惯独自一人呆在密封呆空间里 日光灯，去死吧。。。]]></content>
      <categories>
        <category>无病呻吟</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年度计划]]></title>
    <url>%2F2019%2F01%2F22%2F%E7%9B%AE%E6%A0%87%2F2018%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[2017已经过去啦，来简单规划下2018吧 订个最重要的目标，到2019前存活 1.戒烟，抽得有点猛了2.学车，估计悬3.工作，emmmmm，没啥新想法，到深圳吧4.jts，目标下载量1w，星星100 好了，没了]]></content>
      <categories>
        <category>目标</category>
      </categories>
      <tags>
        <tag>目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java]]></title>
    <url>%2F2019%2F01%2F22%2FJava%2Fjava%2F</url>
    <content type="text"><![CDATA[Java底层机制总结 JVM虚拟机A Java virtual machine (JVM) is a virtual machine that enables a computer to run Java programs as well as programs written in other languages that are also compiled to Java bytecode JVM主要功能模块包括类加载器、执行引擎和垃圾回收系统 内存区域方法区 （类信息，常量，静态常量）堆（实例对象）虚拟机栈（局部变量表，操作数栈，动态连接，方法出口）本地方法栈（Native方法）线程计数器（线程当前执行的字节码行号指示器） java的所有变量都存储在主内存中，线程拥有共享变量副本内存8种操作：lock，unlock，read，load，use，assign，store，writelock – unlock次数相同才能平衡 类的内存结构对象头 Java对象头详解实例数据对齐填充字节 类加载器的加载进程类的生命周期 – 加载，验证，准备，解析，初始化，使用和卸载Java虚拟机类加载的过程 触发时机 new，读取设置一个类的静态字段，调用一个类的静态方法 反射调用 父类 入口类（包涵main的类） java.lang.invoke.MethodHandle 加载流程加载 全限定名获取二进制字节流 静态结构转换为运行时数据结构 生成内存代表类的java.lang.Class 验证 文件格式(class文件格式，版本） 元数据（语义） 字节码验证（数据流和控制流） 符号引用验证 准备 初始化变量 解析 将常量池符号替换为直接引用 初始化 对类变量进行赋值及执行静态代码块 加载器种类启动类加载器（Bootstrap ClassLoader） 核心类扩展类记载器（Extension ClassLoader） 扩展的核心类应用程序类加载器（Application ClassLoader）用户classpath上指定的类 （可直接ClassLoader.getSystemClassLoader()获取） 双亲委派模型加载优先级 启动类加载器 &gt; 扩展类记载器 &gt; 应用程序类加载器 GC算法Java虚拟机详解04—-GC算法和种类【重要】GC：Garbage Collection 垃圾收集这里所谓的垃圾指的是在系统运行过程当中所产生的一些无用的对象，这些对象占据着一定的内存空间，如果长期不被释放，可能导致OOMJava中，GC的对象是Java堆和方法区（即永久区） 判断回收算法引用计数算法根搜索算法（栈帧的本地变量表，静态属性引用，常量引用，jni引用） 现代的GC算法标记-清除复制算法标记-整理分代搜集 Enden - Survivor:Survivor - 年老代 - 永久代Minor GC &amp;&amp; Full GC/Major GC GC搜集器Serial收集器ParNew收集器Parallel Scavenge收集器Serial Old收集器Parallel Old收集器CMS（Concurrent Mark Sweep）收集器 并发G1收集器 并发 分代 引用类型强引用 有用，内存异常都不回收软引用 有用但非必须 内存即将异常时回收弱引用 不会阻止垃圾回收虚引用 对象被收集器回收收到一个系统通知 finalize()可以在标记后复活对象，重载了finalize()的对象在标记后会进入一个F-Queue]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>技术总结</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Music in mac]]></title>
    <url>%2F2019%2F01%2F22%2F%E9%9F%B3%E4%B9%90%2FMusic-in-mac%2F</url>
    <content type="text"><![CDATA[好久没搞录音，最近在练543的打上花火，感觉弹得还可以，又燃起了录音的热情了先把声卡搞起来]]></content>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绝望]]></title>
    <url>%2F2019%2F01%2F22%2F%E6%97%A0%E7%97%85%E5%91%BB%E5%90%9F%2F%E7%BB%9D%E6%9C%9B%2F</url>
    <content type="text"><![CDATA[面试广发又失败了，死在了之前那些面试题上，在相同的地方栽了无数的跟头，还是不会吸取教训。。只能安慰自己，只要是活着， 总会有美好的事情发生吧。。]]></content>
      <categories>
        <category>无病呻吟</category>
      </categories>
      <tags>
        <tag>感想</tag>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终末少女旅行]]></title>
    <url>%2F2019%2F01%2F22%2F%E5%8A%A8%E6%BC%AB%2F%E7%BB%88%E6%9C%AB%E5%B0%91%E5%A5%B3%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[超级喜欢这部番，真让人脸扁～配乐，画风，设定都很赞，不火真是没天理 有一天早上骑摩托的时候在想，如果世界的其他人都消失了（或者是只有我被传送到了平行世界），会是怎么样，也许过几天就会疯掉吧。。]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三个月纪念]]></title>
    <url>%2F2019%2F01%2F22%2F%E8%AE%B0%E4%BA%8B%2F%E4%B8%89%E4%B8%AA%E6%9C%88%E7%BA%AA%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[距离职到现在已经有三个月了，当时想的很多事情，有的发生，有的没有，不过无所谓啦。 其实事情本来是很简单的，就是受不了那鬼气氛的煎熬，担心自己捅大篓子，还有就是想找点时间干点自己想做的事情而已。 （都干了些啥呢。。） 吉他社app的优化，可惜站长转ionic了，通过正则开发第三方客户端（一点都不看好混合框架，特别是这种要到底层优化的app） 地狱少女看完（emmmmm 能登大法好）空轨推完（真是大坑，推了一个多星期） 炉心融解练习（有模有样了，但是现在不知为啥烂得录了） javfor（emmmmmm） 然后找工作就跟以前一样啦，没准备老是去碰钉子，搞得人生一片灰暗，害怕给周围人压力，老是希望自己消失算了。 不过最近心情有开始好起来，昨天晚上一起床，发现自己还活着，真是好开心。。 那个谁，羡慕就没必要了。。]]></content>
      <categories>
        <category>记事</category>
      </categories>
      <tags>
        <tag>感想</tag>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[声之形]]></title>
    <url>%2F2019%2F01%2F22%2F%E5%8A%A8%E6%BC%AB%2F%E5%A3%B0%E4%B9%8B%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[一部跟《你的名字》画风很像的动漫，很喜欢这种风格的动漫。不过属于单身狗保护协会禁播的片子罢了。 想现在的年轻人啊，高中都有女朋友了，还想要自杀，自杀你妹啊(╯°Д°)╯︵ ┻━┻，都是人生赢家好吗，我也要自杀，我不管 不过好在最后结尾是GE，男主女主都解了心结，可喜可贺，比较可气的是男主都没回应女主的心意，月亮你妹啊月亮(╯°Д°)╯︵ ┻━┻ 最近在家废柴不下去，该好好想好出路了，啊啊啊，真是麻烦，活着真麻烦。（life &amp;&amp; movie 小时候并没有听力有问题的女同学，有也是奇丑无比，跳下楼，就会死，不过自杀失败倒是有点道理的）]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿修罗]]></title>
    <url>%2F2019%2F01%2F22%2F%E5%8A%A8%E6%BC%AB%2F%E9%98%BF%E4%BF%AE%E7%BD%97%2F</url>
    <content type="text"><![CDATA[今天又懒癌发作，什么都不想干，修了下空调，拆了个床，看昨天刚下下来的动漫，本来还以为是《鱼》来着，结果却是《阿修罗》 不过还不错，小鬼拿这斧头贼帅，怎么都打不死。可惜了女主。比起周围的危险和敌视，背叛伤害要更深点吧。 在生存面前，每个人都一样吧 话说大师剁手那一场景，真是狠 又看了一部鱼来着，感觉太恶心了]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[被嫌弃的松子的一生]]></title>
    <url>%2F2019%2F01%2F22%2F%E7%94%B5%E5%BD%B1%E5%B0%8F%E8%AF%B4%2F%E8%A2%AB%E5%AB%8C%E5%BC%83%E7%9A%84%E6%9D%BE%E5%AD%90%E7%9A%84%E4%B8%80%E7%94%9F%2F</url>
    <content type="text"><![CDATA[活着没什么意义，偶尔疯狂一把，可以原谅我吧 在这里又看到那句“生为人 我很抱歉”这部剧简直就是太宰治人间失格的翻版]]></content>
      <categories>
        <category>电影小说</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[该是结束了]]></title>
    <url>%2F2019%2F01%2F22%2F%E8%AE%B0%E4%BA%8B%2F%E8%AF%A5%E6%98%AF%E7%BB%93%E6%9D%9F%E4%BA%86%2F</url>
    <content type="text"><![CDATA[端午节早上起来，打扫了下房间，洗了下澡，发现夏天到了 小时候嘛，很喜欢夏天的，跟着小朋友们去河里海里到处玩，烧烤啊也怎么搞都不会厌烦，晚上还偷偷翻墙去学校里去垫猎，一坨人躲到女厕所里，最喜欢的就是网上停电，点着蜡烛玩自己画的四国军棋，自己画的大富翁。 后来呢，上了高中，就很无聊了，整天写试卷的，读书读残了。 再后来呢，大学就开始宅起来了，就无所谓的冬天夏天了，不过大学那段时间最喜欢的还是春天的樱花。 打扫完之后呢，开始看之前买的《人间失格》，忽然想起高中那时候那个叫谁来着，很奇怪的一个人，印象很深刻就是记不住他的名字，说我虚伪，当时我就“哇 还真有人能看出我是装的”，但后来我才发现，其实自己也不知道有那些是装出来，有些是真的。 不过可以确定的几点是，我真的很喜欢大学二年级后到毕业的那段时光，真的很喜欢吉他，至少我现在还怀念那段时间的。至于编程写代码，虽然干了很久，后来越来发现是当时害怕将来会一无是处被饿死，才努力去学的（后来才发现，其实学得再厉害，也没办法将这种心态消除掉）。 不管怎么说，感觉自己还是蛮虚伪，真实的想法憋着不说（其实大部分时候是觉得害怕），所以就愈发害怕跟别人交流，怕被别人看出来，自己眼里真实的自己嘛，其实也没有那么不堪。 还有对公司的一些真实的想法，喜欢他的放任，每天早上迟到那么久也没人管，主管很好，老阳也很好，甚至觉得小组那些人也挺好的，另外一方面不喜欢他的工作环境，跟个网吧试的，不喜欢他的厕所，后面也管理愈发严格，还有那傻逼pm，我。。（不说ctm了） 总之，干着其实还好，就是感觉像颗螺丝钉了，虽然很难，但是我还是要去试一下，有没有什么工作，能让我有种锤子的感觉。 下周就得去辞职了，前路黑暗，炎热的夏天里，winter is comming。]]></content>
      <categories>
        <category>记事</category>
      </categories>
      <tags>
        <tag>感想</tag>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非典型生活]]></title>
    <url>%2F2019%2F01%2F22%2F%E8%AE%B0%E4%BA%8B%2F%E9%9D%9E%E5%85%B8%E5%9E%8B%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[早上7点爬起来，算准了时间跑到车站，发现钱包没带，身份证在钱包里，f*ck,买不了票，打车回来取，顺便滑个翔，打车回去，迟到了一小时高铁到广州转地铁到东山口，f*ck,12点了彪哥请喝星巴克，第一次喝星巴克，摩卡，有点太甜了，下次点不加糖的拿铁彪哥请吃饭，等超过15min减15块吃完饭，开始办正事，预料之中的不顺利，各种意外各种不行，预料30min搞定的事情，在餐厅里搞了一下午（全程划水）最后试了n多方法，终于将手机搞定，走路10min到羊城通，测试花费了3 5s,完事骑自行车沿珠江，骑到天黑黑的打车去吃牛肉火锅，又是彪哥请客，上菜很快，吃得很慢8点多吃完饭，打车去广州南，发现没高铁票了，f*ck走到附近的汽车站，9点半，买了10点半的大巴10点半过，开车，睡得迷迷糊糊，突然让下车蒙B了。然后让去厕所拉尿尿检，搞得跟毒贩似的，原来警察查吸毒f*ck继续开，到12点，深圳下车，大雨，上的士，有种生死停留的感觉，都让人怀疑是不是车祸的死前记忆，刚好安全带坏了司机最后还搞错了了，还好平安回来了，炒米粉的小哥因为下大雨，开始收摊了 阴阳师白狼终于升上6星，哇哈哈 有时候，特别是最近一段时间，很累，却不知道自己在干吗晚安～明天还要早起。。]]></content>
      <categories>
        <category>记事</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1Q84]]></title>
    <url>%2F2019%2F01%2F22%2F%E7%94%B5%E5%BD%B1%E5%B0%8F%E8%AF%B4%2F1Q84%2F</url>
    <content type="text"><![CDATA[终于看完了1Q84啦，想想之前没头没尾的看完第二本真是逗比最高兴的是还是有个好结局，祝福青豆天吾 相反xxxholic那死作者。。“您好，你的快递（刀片）到了，请您签收下” 今天好累啊，跑了一整天，没什么成果，受不了了！&gt;_&lt;]]></content>
      <categories>
        <category>电影小说</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[xxxHOLic]]></title>
    <url>%2F2019%2F01%2F22%2F%E5%8A%A8%E6%BC%AB%2FxxxHOLic%2F</url>
    <content type="text"><![CDATA[边打阴阳师边看完这部番，一开始画风诡异，剧情欢乐，各种日常，后面突然开始精致起来，也变得忧伤起来。嘛 还算可以。就是有点基基额。。 （额，发现还有一集没看完，希望是个好结局，超喜欢座敷童子的声音∠( ᐛ 」∠)＿ ） 另外最近练炉心融解练上瘾了，有点走火入魔的节奏额 人生的齿轮又开始旋转，希望两个月后会顺利点把]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Happy New Year]]></title>
    <url>%2F2019%2F01%2F22%2F%E8%AE%B0%E4%BA%8B%2FHappy-New-Year%2F</url>
    <content type="text"><![CDATA[新的一年，回来深圳后第一件事就是把牙拔了，坑爹的牙额。]]></content>
      <categories>
        <category>记事</category>
      </categories>
      <tags>
        <tag>不孝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[又一年的公司年会]]></title>
    <url>%2F2019%2F01%2F22%2F%E8%AE%B0%E4%BA%8B%2F%E5%8F%88%E4%B8%80%E5%B9%B4%E7%9A%84%E5%85%AC%E5%8F%B8%E5%B9%B4%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[最近没怎么写博客了，主要是没遇到有什么比较有感触的东西，技术方面又没有什么进展，生活归于平淡。。 颠簸堵车了把个小时，在车上晕死了过去，果然对大巴公交这种鬼玩意还是受不了。下了车后感觉很冷，果然天气跟去年的一样阴冷阴冷的，不过玩玩游戏，换换奖品什么的还是挺开心的。年会表演的话，今年没有参加了，感觉还好吧，就是拖到后面抽奖的时候又是困又是恶心的，都没什么心情激动。今年没什么期待，回归正常的运势–阳光普照奖，挺好，不需要激动啥。后面又跟测试的那帮哥们去喝了酒，感觉我跟测试的更合的来。。 后面发现其实一加每个人都挺kind，也没有之前想的那么糟糕 就是感觉还是要坚持自己的方向吧，cm已死，诚然跟平哥说的，一加是一个买硬件的公司，我也是该寻求自己该走的方向了。。 这也许是最后一次参加一加年会了。。]]></content>
      <categories>
        <category>记事</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nfc年度总结]]></title>
    <url>%2F2019%2F01%2F22%2FAndroid_Nfc%2FNfc%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[NXP代码整合：NXPNFCProject framework: 定义Nfc数据类型等 – NXPNFCProject/NFC_NCIHAL_baseNfcNci: Nfc行为实现，开启关闭Nfc，Tag分发系统，beam等 – NXPNFCProject/NFC_NCIHAL_Nfclibnfc-nci: Hal层实现 – NXPNFCProject/NFC_NCIHAL_libnfc-ncifirmware: NFC固件 – NXPNFCProject/NXPNFCC_FWdriver: NFC驱动 – NXPNFCProject/NXPNFC_I2CDriver spi: framework，app，hal – NXPNFCProject/NXPNFC_P61_SPI_Servicesdriver – NXPNFCProject/NXPNFC_P61_SPI_Services]]></content>
      <categories>
        <category>Android_Nfc</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>framework</tag>
        <tag>nfc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无头骑士异闻录]]></title>
    <url>%2F2019%2F01%2F22%2F%E5%8A%A8%E6%BC%AB%2F%E6%97%A0%E5%A4%B4%E9%AA%91%E5%A3%AB%E5%BC%82%E9%97%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[很无聊的一个动漫，不过妖刀的人设倒挺不错的。。]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京之旅]]></title>
    <url>%2F2019%2F01%2F22%2F%E8%AE%B0%E4%BA%8B%2F%E5%8C%97%E4%BA%AC%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[掉到了一个巨坑的项目，搞了好都没搞定的项目，boss一怒，赶紧派我们的软件工程师到现场搞一搞，老蒋说北京冷多加件衣服，然后就两天匆匆忙忙的准备了了一些测试参数，定了早上7:50的飞机，就飞北京了。 不想写太多，记一下一些感受吧。 1.不喜欢北京的天气，过去直接把嘴唇给冻裂了，疼得要死，然后又是双腿过敏一样发红发痒，估计是粉尘的原因。 2.又是早上5点起床，还好有经验早上买了个面包吃，不然坐飞机就是死掉的感觉，不过刚起来还是恶心想吐，果然程序员的天敌就是早起。 3.北京忽冷（室外）忽热（室内）的情况，真是搞死我，进到室内就是浑身发痒，估计就是我最受不了的地方了。 4.去见了吉他社的站长，意外的跟我想象中的不一样，也是跟我一样不善言辞的人，还以为应该会能说会道一点。不过人很好应该。 5.明白了自己掉入的坑究竟有多大，根本就填不了的，尽自己的努力填咯，希望自己离开的时候能好点吧 6.发现现在的自己没有像以前那么玻璃心，像被人忽略，没有人关心什么的，笑笑就过去，不过也偶尔会感觉很累，特别是有时候莫名的伤感到像流泪。 7.因为旅馆的网络不好，跑到北京的一个网吧下东西，看到那些网瘾少年在打游戏，突然明白那些送儿子女儿到杨永信的父母是怎样的心情，看着他们打游戏的脸，只能感受到的只有绝望，特别是在北京五道口这个地方，即使当时大学整个宿舍最颓废的时候，都没有这种感觉。 8.早上吃的鸡蛋灌饼贼好吃的 9.飞机，高铁，其实我不怎么喜欢，太快了。我还是比较喜欢火车，自行车，可以看清沿途的风景，人。即使是萧条的，丑恶的。 10.北京的确是个创业的地方，深圳，嗤～ 从宝安机场下来，坐上开着车窗的红的，脑子被飞吹傻了，嘴唇也不痛，至少一年前做出的选择，也是有些正确的。 聚散离合，去了又来，来了又去，下一站会是哪里呢？ 无所谓，反正在路上。。。]]></content>
      <categories>
        <category>记事</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雏菊]]></title>
    <url>%2F2019%2F01%2F22%2F%E7%94%B5%E5%BD%B1%E5%B0%8F%E8%AF%B4%2F%E9%9B%8F%E8%8F%8A%2F</url>
    <content type="text"><![CDATA[很久没看电影了，突然想起在大学春天也有大片的雏菊。。 片尾曲感觉很好， 不知道自己在讲什么了。。]]></content>
      <categories>
        <category>电影小说</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[无法访问此网站]]></title>
    <url>%2F2019%2F01%2F22%2F%E6%97%A0%E7%97%85%E5%91%BB%E5%90%9F%2F%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E6%AD%A4%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[在某天，这个blog也会这样吧。。。]]></content>
      <categories>
        <category>无病呻吟</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NFC金融]]></title>
    <url>%2F2019%2F01%2F22%2FAndroid_Nfc%2FNFC%E9%87%91%E8%9E%8D%2F</url>
    <content type="text"><![CDATA[最近两天研究了下移动金融的东西，水是相当的深。 NFC有三种模式：点对点(p2p)，读/写卡(reader/writer)，卡模拟(card emulation),在移动金融领域中一般只有卡模拟模式。 乱七八糟的卡说到卡模拟，先要明白这里的卡指的是什么，这里的卡指的是集成电路卡(Integrated Circuit Card,IC卡),又称智能卡(Smart card),还有一些乱七八糟的叫法。et.新的银行卡，工卡，公交卡等，基本都是这玩意了。 另外的还有身份识别卡（Identification Card），比较老的只读卡。et.老的门禁卡，停车卡 还有一个很乱的概念cpu卡,不清楚是什么的东西 ic卡ic卡又分为接触式IC卡和非接触式IC卡，很形象。。没必要解释。。接触式IC卡常见的有银行卡，插入atm应该就是接触式的。。所以银行卡具有接触式IC卡和非接触式IC卡(pos机)的两种功能。 ISO14443协议是非接触式IC卡标准(Contactless card standards)协议。 nfc卡nfc卡，故名思意，就是基于nfc的ic卡，也就是作用距离在10厘米以内的ic卡。 近场通信（Near Field Communication,NFC）是一种短距高频的无线电技术，在13.56MHz频率运行于10厘米距离内。nfc卡的种类，其实就是各个公司基于标准的实现 NfcA — ISO 14443-3ANfcB — ISO 14443-3BNfcF — JIS 6319-4NfcV — ISO 15693IsoDep — ISO 14443-4M卡指的是Mifare卡，MIFARE Classic是NfcA ，MIFARE DESFire是IsoDep。 PS. 银行卡非接触式部分是基于IsoDep，接触式部分是基于ISO7816实现的【NFC】 NfcA/NfcB/NfcF/NfcV/IsoDep/Ndef/Mifare/Felica/Pboc/ISOxxxx 都是些什么鸟玩意？ 卡模拟卡模拟到现在有两种实现方案，一种是基于软件的，被称为主机卡模式（Host-based Card Emulation，HCE），另外一种是基于硬件的（不知道叫什么）。这里重点关注的是基于硬件的做法。既然是卡模拟，那么最大的问题就是安全的问题，所以有了SE出现。 SE安全元件（Secure Element，SE），通常以芯片形式提供。为防止外部恶意解析攻击，保护数据安全，在芯片中具有加密/解密逻辑电路。 现在主要有三种形态 内置SE模式（eSE）UICC（SIM卡）AdvancedSecurity SD card（ASSD SD卡） 模拟的卡（APPLET)模拟的卡是一种程序，运行于SE中，也是用java开发，叫做java card applet概念还是很模糊 – 比如所APPLET是怎么加载到SE上的 TSM发卡服务器,APPLET由TSM来发送安装。。 SMARTCARDEMVPBOC]]></content>
      <categories>
        <category>Android_Nfc</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>nfc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[目标]]></title>
    <url>%2F2019%2F01%2F22%2F%E7%9B%AE%E6%A0%87%2F%E7%9B%AE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[避免自己对自己的言而无信，会把目标写在这里，当作对某猪头的诚偌。以上 （后续补充） 团子千本樱 吉他社app 准备后路]]></content>
      <categories>
        <category>目标</category>
      </categories>
      <tags>
        <tag>目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近日]]></title>
    <url>%2F2019%2F01%2F22%2F%E8%AE%B0%E4%BA%8B%2F%E8%BF%91%E6%97%A5%2F</url>
    <content type="text"><![CDATA[国庆放假，不出乎自己所料的又宅了7天，各种时间的颠倒，待在小屋子里，白天也要开着灯，感觉莫名的安心，想想明天要去坐地铁上班就害怕。。(应该是今天早上） 上班什么的其实没什么，相反的倒是十分喜欢写代码，只是对出门产生了恐惧，害怕去接触各种各样的人，每天走得很近，却不知道他们在想什么，只得小心翼翼地说话，小心翼翼地做事。之前想找个小的创业公司，也是因为人少的话或许会简单点吧。（可以理解动漫里那些宅么了，不过老子是有锻炼的好么） 国庆过后就是一年了，之前的计划的一年半也只剩半年，也是该想想以后的路要怎么走了，离开的想法占了很大一部分，但是去哪还不是很确定，但确定的是如果离开深圳，下一个城市也必须是靠海的地方。 总之，先给自己定些小目标，不过想做的事情太多了，接下来的一个星期要理一理，看看什么是自己真正想要的 老爸说，可能20年后还是在老家干着同样的事情，叫我不要学他，其实那种生活才能让人安心下来，我很羡慕那种生活，不过要是真是有这种生活，我应该会是受不了的吧，所以人贱就是贱，当得到了自己想要的东西时，却发现自己根本不知道自己想要什么。 不过另外一方面，虽然不是全部，以前想要的东西基本都有了，比如小时候经常想要的电脑，吉他，自行车，还有之前对一加也頗有期待的，也是各种巧合。。这就是大姐说的念念不忘，冥冥之中，必有回响吧。所以，对那些多么不切实际的想法，只要肯坚持，必定能实现的。 最近对自杀的幻想次数貌似有所增加，人生的意义这个问题老是困扰着我，但这个问题老早就有了答案，那就是(c + d + e + f + g + a + b + …) * 0 = 0; 人生是没有意义的，但是仍在想假设境第还在会是怎样的，他的人生会是彩色的还是灰白的，虽然这个假设半毛钱意义都没有，每次回到家，特别害怕碰到，他奶奶，看到我，就开始流泪，说当初如何如何，所以相应的，我也开始害怕起回家了。。 外面在下雨，一场秋雨一场凉，估计就要开始冷下来了吧，每天听着地铁的尖啸声，听着时雨的moment A rhythm，有时候都怀疑自己是否活着，不管怎么怎么说，开始厌倦了这样的生活 想要改变，希望自己改变，先祝自己改变顺利。。对了，二姐的生日快到了，想想要送什么吧 一年之后，仍旧迷茫]]></content>
      <categories>
        <category>记事</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[樱花庄的宠物女孩]]></title>
    <url>%2F2019%2F01%2F22%2F%E5%8A%A8%E6%BC%AB%2F%E6%A8%B1%E8%8A%B1%E5%BA%84%E7%9A%84%E5%AE%A0%E7%89%A9%E5%A5%B3%E5%AD%A9%2F</url>
    <content type="text"><![CDATA[没有结局真令人不爽啊距交大樱花祭还有半年，好怀念呐看着一群高中生 唉真的老了～]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希德尼娅的骑士]]></title>
    <url>%2F2019%2F01%2F22%2F%E5%8A%A8%E6%BC%AB%2F%E5%B8%8C%E5%BE%B7%E5%B0%BC%E5%A8%85%E7%9A%84%E9%AA%91%E5%A3%AB%2F</url>
    <content type="text"><![CDATA[一口气看完 额 25集，感觉还可以，不过感觉又是一个天坑，还是去看漫画好了。 一开始感觉脸怪怪的，不过习惯了还好，想想要是能晒晒阳光就不用吃饭的话。。看了网上的评论，貌似还挺高的，但感觉没什么深度。看那外星人还是肉肉的。。唉 难道外星人一定就是肉肉的么。。]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nfc学习]]></title>
    <url>%2F2019%2F01%2F22%2FAndroid_Nfc%2FNfc%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[证书相关12$ openssl x509 -in platform.x509.pem -outform der -out platform.x509.der$ xxd -c 10000 -ps platform.x509.der]]></content>
      <categories>
        <category>Android_Nfc</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>nfc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玲音（Serial Experiments Lain）]]></title>
    <url>%2F2019%2F01%2F22%2F%E5%8A%A8%E6%BC%AB%2F%E7%8E%B2%E9%9F%B3Serial-Experiments-Lain%2F</url>
    <content type="text"><![CDATA[网瘾少女的妄想 三次元的乱入 怀疑人生系列 程序的暴走 音乐都不错 特别喜欢其中的一个场景 既视感]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[革命机valvrave]]></title>
    <url>%2F2019%2F01%2F22%2F%E5%8A%A8%E6%BC%AB%2F%E9%9D%A9%E5%91%BD%E6%9C%BAvalvrave%2F</url>
    <content type="text"><![CDATA[老久没看动漫了，感觉是要脱宅的节奏啊。。。 机战的动漫很少看，除了鲁鲁跟翠星，不过感觉革命机比前两部差远了。。 看贴吧把翔子称为智商翔真是贴切（笑死）。。 第一季的各种展开感觉智商有点跟不上。。 感觉就白毛撑起了整个革命机valvrave。。 后面越来越腐了，基佬退散！！！ 不过好在结局还不错的（妹妹跟妹控都没领便当，可喜可贺）。。。]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生分屏原理]]></title>
    <url>%2F2019%2F01%2F22%2FAndroid%2F%E5%8E%9F%E7%94%9F%E5%88%86%E5%B1%8F%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[分屏代码在AOSP其实老早就存在了，就一直没有开启而已，在6.0版本可以通过设置系统属性ro.build.type改为userdebug,并在开发者选项中开启多窗口模式,然后在最近任务上就会个按钮可以实现分屏。 通过adb命令也可以实现分屏1$ am task resize 25 0 720 1080 1920 在最近任务的调用链123456RecentsActivity#onTaskResize -&gt;RecentsResizeTaskDialog#placeTasks -&gt;SystemServicesProxy#resizeTask -&gt; ActivityManagerNative#resizeTask -&gt; ActivityManagerService#resizeTask -&gt; ActivityStackSupervisor#resizeStackLocked 在am的调用链1234Am#runTaskResize-&gt; ActivityManagerNative#resizeTask -&gt; ActivityManagerService#resizeTask -&gt; ActivityStackSupervisor#resizeTaskLocked ActivityStackSupervisor的实现123456789foundStackWithBounds -&gt;ActivityStackSupervisor#moveTaskToStackLocked -&gt;ActivityStackSupervisor#resizeStackLockedActivityStackSupervisor#moveTaskToStackLocked - &gt; WindowManagerService#moveTaskToStackActivityStackSupervisor#resizeStackLocked -&gt;WindowManagerService#resizeStack WindowManagerService的实现1234WindowManagerService#resizeStack -&gt;TaskStack#setBoundsTaskStack#resizeWindows -&gt;updateLayout?? 看来让人心情不好的乱七八糟源码分析1234567891011121314151617181920212223242526272829303132333435363738394041424344//---&gt; frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.javavoid resizeTaskLocked(TaskRecord task, Rect bounds) &#123; task.mResizeable = true; final ActivityStack currentStack = task.stack; if (currentStack.isHomeStack()) &#123; // Can't move task off the home stack. Sorry! return; &#125; // 找到给定区域相同的栈 final int matchingStackId = mWindowManager.getStackIdWithBounds(bounds); if (matchingStackId != -1) &#123; // There is already a stack with the right bounds! if (currentStack != null &amp;&amp; currentStack.mStackId == matchingStackId) &#123; // Nothing to do here. Already in the right stack... return; &#125; // Move task to stack with matching bounds. moveTaskToStackLocked(task.taskId, matchingStackId, true); return; &#125; // 栈里只有一个task，直接resize栈 if (currentStack != null &amp;&amp; currentStack.numTasks() == 1) &#123; // Just resize the current stack since this is the task in it. resizeStackLocked(currentStack.mStackId, bounds); return; &#125; // 挪动task到新的栈 // Create new stack and move the task to it. final int displayId = (currentStack != null &amp;&amp; currentStack.mDisplayId != -1) ? currentStack.mDisplayId : Display.DEFAULT_DISPLAY; ActivityStack newStack = createStackOnDisplay(getNextStackId(), displayId); if (newStack == null) &#123; Slog.e(TAG, "resizeTaskLocked: Can't create stack for task=" + task); return; &#125; moveTaskToStackLocked(task.taskId, newStack.mStackId, true); resizeStackLocked(newStack.mStackId, bounds);&#125; 分屏的核心是task跟bound，需要看一下task是怎么裂变的]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[aidl的使用]]></title>
    <url>%2F2019%2F01%2F22%2FAndroid%2Faidl%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[接口文件aidl123456package com.zst.xposed.halo.floatingwindow3.services;interface IActivityManagerService &#123; void snapActivityTop(int id); void snapActivityBottom(int id);&#125; manager123456789101112package com.zst.xposed.halo.floatingwindow3.services;import com.zst.xposed.halo.floatingwindow3.IActivityManagerService;public class ActivityManager extends IActivityManagerService.Stub &#123; public ActivityManagerService mService; public ActivitManager(ActivityManagerService service) &#123; mService = service; &#125; public void snapActivityTop(int id) &#123;&#125; public void snapActivityBottom(int id) &#123;&#125;&#125; service123456789101112131415package com.zst.xposed.halo.floatingwindow3.services;import android.app.Service;import android.content.Intent;import android.os.IBinder;import android.support.annotation.Nullable;public class ActivityManagerService extends Service &#123; @Nullable @Override public IBinder onBind(Intent intent) &#123; return new ActivitManager(this); &#125;&#125; client12345678910111213ActivityManager manager = null;private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; manager = (ActivityManager)MyAIDLService.Stub.asInterface(service); manager.snapActivityTop(TOP) &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; manager = null; &#125;&#125;;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深圳故事2]]></title>
    <url>%2F2019%2F01%2F22%2F%E8%AE%B0%E4%BA%8B%2F%E6%B7%B1%E5%9C%B3%E6%95%85%E4%BA%8B2%2F</url>
    <content type="text"><![CDATA[最近很忙，帮着吉他社做了app，偶尔忙到晚上两三点，似乎是回到了大学的熬夜帮别人做毕设的时代，还有新堂花园F5默默的走了一人，却一点也不感到悲伤。。 怎么说呢，毕业满一年了，没有什么实感，去年的很多事情都不是很记得了，偶尔也想把那时候的一些想法和经历记下来，却总是没心情，或者老是找些要向前看的借口，感觉也渐渐变懒了啊。 喝完酒后的第二天，我们聚到张的房间，商量着未来的计划，当时打算先到上梅林找我们的部长（可笑的是直到离职的时候连部长还没见过），张还是不死心，想去做最后的一搏，那时候我就没怎么报期望了。然后再到深圳那边找房子，然后再回来把行李搬过去。这时候那个刚考过的一个哥们过来敲门，那时候我们都没有心情开门，以为是跟我们一级的hr过来安慰我们，敲了很久之后开口说话，又过了很长一段时间，看着他们三个不想动，我就过去帮他开了门。后面进来说了什么我有点忘了，好像是关于对公司的这种做法很惊讶很气愤之类的话，反正当时也挺心不在焉的，说明了自己情况后安慰了他说不会被开除的啦之类的话。后来他松了一口气（心里作用？），说保重后会有期就关门走了。 之后就背了个书包叫了uber在门口等车，记得当时天气很晴朗，风却很大，地上的沙尘卷起了一个个漩涡，那感觉还蛮凄凉的。。 （现在暂时离开深圳了，那时候的故事也渐渐的淡忘，当时的情绪也记不大清了，捡记得的事情写吧） 后面就直接去vivo的深圳总部找部长，他们的部长跟我的部长还不不一样，然后我就跟我们部长谈了，都是围绕着本分在那里废话，谈了半个多小时，我最后放弃了，就没事聊聊，现在想想估计部长也没拿hr没办法，也没有心情去保我们，毕竟又不是亲戚啥啥的。中午临走前还一起吃了顿饭，另外一个部长还比较仗义，说是要给我们推荐工作。 (在这里不知道能不能被看到 郑重表示感谢了) 吃完饭后，就算是与vivo的缘分已尽了，说来讽刺，我还记得当时vivo招应届生的宣传语 – “最好的遇见，是有未来” 吃完饭后，四人就一同去找房子，一开始想去找不是中介的房子，转了几圈没找着，就钻入间Q房网，端水倒茶，还是比较客气的，后来两个中介小哥貌似是跟张老乡，聊得很来，聊了有大半天，然后就出发去看房子，那房子我记得离地铁有点远，不过是小区房，应该是我至今见到最好的房子了，四个人在那间房间这里锤锤，那里瞅瞅，觉得还比较满意，我们就决定第二天给钱。总共好像要出1万 那天晚上，张女朋友过来，然后我跟另外两人就住一起，两个人就越觉得不划算，说现在的状况，我们只配去住那些破烂的农民房，这么高档的小区房住了也心不安balabala的，还谈到拿不出那么多钱，说要第二天一起反悔。然后又谈到了以后的路怎么走，小胖就想出国，胡说是要去广州。 第二天，跟房东直接谈，后面过真反悔了，小胖咬死了说拿不出那么多钱，房东坚持要一次付清，搞得大家都很不愉快，最后没办法就不租了，小胖这时也提出要去找他亲戚去了，四个人就变三个人，打辆车来到了白石洲住酒店。 （好累啊，这几天呆在家里压力巨大，下去抽个烟先～ 这周有空就写写吧） Valar Morghulis 后来呢，胡忘记去了哪里，只剩和张在酒店里，vivo的部长后面给我们推荐了家公司，在一个下午就过去面试了。 去了之后好像也没怎么面，估计是技术层面简历写的已经过关了吧，张就面了会，不过最后也通过了，就是工资还没谈，直到我们到了楼下才跟我们说，（涉及到公司的机密，我就不说多少了，反正比当时预料的最低工资还要略低点）。后面和张回酒店，纠结了半天，鉴于我们这种情况，还是去了。后面就开始找房子，期间酒店还漏水，滴得满屋子都是，换了个房间，总共住了有十几天酒店，临走还忘了给酒店刷差评。。 房子在新塘花园那边，跟别人合租，后面稳定住4个人，戏称新塘花园f4。（前前后后来了有走了好几个人,后面改新塘花园f5了)。胡还跟我住了有两三天，后来就去广州了（听说后面又来了深圳，不过没有再联系便是） 新塘花园跟新公司的故事，就开始平淡了起来，后面应该是2.5吧，到离开这家公司为止，人来人往，聚散无常，深圳就是这种地方。]]></content>
      <categories>
        <category>记事</category>
      </categories>
      <tags>
        <tag>故事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java里的坑]]></title>
    <url>%2F2019%2F01%2F22%2FJava%2Fjava%E9%87%8C%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Comparator 在jdk1.6可以返回1或0，在jdk1.7必须返回一对相反数，像下面的Comparator是不工作的1234567private class SortByUseCount implements Comparator&lt;ItemInfo&gt; &#123; @Override public int compare(ItemInfo o1, ItemInfo o2) &#123; return o1.useCount &lt; o2.useCount ? 0 : 1; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏]]></title>
    <url>%2F2019%2F01%2F22%2F%E6%B8%B8%E6%88%8F%2F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[昨天把去年没打完的寄生前夜3给打完，结局真是令人感动，好久没玩过这么好的游戏了。 小时候玩过很多游戏，不过在那时候能通关的游戏并不多，因为太难了，也没有攻略，一般操作菜的我老屎在了第一关。 唯一记得通过的是跟群总一起打的热血篮球，靠着这俩个打招打过，我记得最后一队是那个会闪现的那一对，一开始打得很辛苦，我们直接把对方的篮筐全拆了装到我们这边了。这个游戏印象最深的石头箱子可以砸自己的队友，于是游戏变成跟三叉戟一样，我从美德中汲取里力量，保护我的敌人，痛击我的队友。ʅ（´◔౪◔）ʃ 初中那时经常去电子游戏店里玩，类似于现在的网吧，有点店还有桌球之类的，村里的小混混也会经常去的那地方。那时候打的游戏也很多，不过我记得能通关的好像也不多，毕竟那时候技术菜，也穷，所以还是更喜欢打桌球（⊙＿⊙）桌球是技术越菜打得越久。 不过通关的也有几个，一般都是修改版的，就是无限气的那张，虽然说是作弊，但也花了不少的力气。 当时有一台四人的风云再起，诸葛亮放了一个青云剑四个人在那里砸次数(伤害等于四个人按的次数），最后好像把机器都砸坏了。 （最后打曹操）三国战记 还有西游释厄传也有点印象，遇到boss的时候圈手柄圈进另外个场景，然后四个人一人一个大招，boss就死了，这个打到很后面，但最后好像还是没有通关 这些游戏还是只在游戏店里面玩得爽，后来用电脑一个人玩，基本都通关了，但没意思。 后面家里买了电脑，就都是电脑游戏了玩得最久的游戏应该是植物大战僵尸，尼玛为了拿成就通关了四次。 植物基本都搜集满了（不过貌似没有玉米炮），当时挂着机让锅牛去捡钱，两个小时捡了一万多，无尽模式打到30多关，后面僵尸都是一坨一坨的过来的，打到后面真是会感到一丝绝望 不过最后还是没拿到全成就，陆陆续续打了两个月，通关了两次，把冒险模式都打完了，最后瓷器太厚那个打了两天，打了无数次1314关后，最后打过15关打到16关的过场动画，叮的一声游戏奔溃了，弹出了一个鸟语对话框，然后我也奔溃了，直接删游戏再也没玩了。 高中时代没完过什么游戏，老实说高中是我最过得无聊的几年。 大学玩得比较多，不过印象深刻也不多第一款应该是极品飞车9，当时在信安实验室跟几个社员联机玩，回宿舍后就装了一个，后面就跟阿宝没事就联机玩。 游戏画面很好，男的帅，女的漂亮，主要玩着不头晕 这个最后一关(比赛都结束了，要躲过警察的追踪，然后飞过个断桥，游戏就结束了）那些六星的警车像疯狗一样的咬你，打了两三天的最后一关都没打过,最后不想搞了，用了作弊器 （最后飞过断桥的场景有些令人伤感） 打得最多应该是war3了吧，大二大三直接把全宿舍给感染了，连小攀攀都拉进来了。 war3老早就接触了，甚至依稀记得我还打过war2，后面看到画面我惊呆了，为什么这个充满了马赛克的游戏在我的记忆中竟是如此的不一样。 不过war3的剧情倒没有rpg图打的多，主要还是单机唉。war3的剧情是三个种族分开的，一开始是精灵族，之后是人族，最后不死族。兽族是额外战役我还没打通。 war3最后一关是不死族的战役，占四个圈好像，当时也打了很久，忘了有没有whosyourdady了。打完之后阿尔萨斯跟伊利丹决斗，最后伊利丹败了，阿尔萨斯坐上了冰封王座，一开始玩的是精简版，后面才补的CG 再之后就是星际2了，sb舍友2v2，或者联机塔防，一张图打一整天，后面撑不住了出去暂停出去吃饭，回来有人掉了打不了于是重头打，打到凌晨。]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在framework添加system service]]></title>
    <url>%2F2019%2F01%2F22%2FAndroid%2F%E5%9C%A8framework%E6%B7%BB%E5%8A%A0system-service%2F</url>
    <content type="text"><![CDATA[在Context.java添加服务名称1234567//---&gt;frameworks/base/core/java/android/content/Context.javapublic static final String THREEKEY_SERVICE = "threekey";@StringDef &#123; ... THREEKEY_SERVICE&#125; 在SystemServicer注册服务123456//---&gt;frameworks/base/services/java/com/android/server/SystemServer.javaprivate void startOtherServices() &#123; ... ServiceManager.addService("ThreeKeyService", new ThreeKeyService); ...&#125; 在ContextImpl.java添加获取服务管理接口12345678910//---&gt;frameworks/base/core/java/android/app/ContextImpl.javastatic &#123; .... registerService(Context.THREEKEY_SERVICE,ThreeKeyManager.class, new CachedServiceFetcher&lt;ThreeKeyManager&gt;() &#123; @Override public ThreeKeyManager createService(ContextImpl ctx) &#123; return new ThreeKeyManager(ctx); &#125;&#125;);&#125; Service的aidl123interface IThreeKeyExService &#123; &#125; Service 本体123public class ThreeKeyService extends IThreeKeyService.Stub &#123;&#125; Manager123456789101112public class ThreeKeyManager &#123; public ThreeKeyManager(Context context) &#123; &#125; static public IThreeKeyService getService() &#123; IBinder b = ServiceManager.getService("notification"); return IThreeKeyService.Stub.asInterface(b); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吉他社软件开发]]></title>
    <url>%2F2019%2F01%2F19%2FAndroid%2F%E5%90%89%E4%BB%96%E7%A4%BE%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[今天去做吉他社的志愿者，感觉应该会很有意义吧。话说现在越来越懒了。 2016-6-11md TuxGuitar这个鬼东西下了半天没下下来，估计很大，md我讨厌sf。。 2016-6-12tuxguitar的app终于跑起来了，不过还是出错了，话说tuxguitar的代码写得真是好。跟那opl的那个鬼东西比起来简直了。。 下面这段代码的意思是app的属性从在自身的attrs.xml定义，包括库文件1xmlns:app="http://schemas.android.com/apk/res-auto" 2016-6-15环境变量搞错了应该用export而不是= 2016-6-16编出来之后还是不能用，是时候熟悉一波gradle和maven了 2016-6-18貌似找到原因了，是配置文件找不到，配置文件没打包到apk里面，啊啊啊看起来好简单的东西为什么就这么难搞，果真是我太弱了么 gradle package apk的实现:AndroidBuilder.java手动打包apk:build apk from the command line添加task:胡搞乱搞 2016-6-19好难啊，还是搞不定，话说为什么在jar还会有android的东西啊 手动打包jar:AndroidStudio导出jar包 2016-6-21就差这个鬼错误了 1Rejecting re-init on previously-failed 2016-6-24最后还是放弃了插件化，手动加载插件并转为了本地的lib，最后搞定了，唉 动态加载这种高大上东西还是太难了 又遇到网络请求这种东西，真是无所不在啊，第一步直接Robolectric,我就问问没有单元测试怎么搞 2016-6-27Robolectric下载了好多东西，又下载不下来，之后手动下，下载后放在1C:\Users\axlecho\.m2\repository]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>JtsViewer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[只有我存在的街道]]></title>
    <url>%2F2019%2F01%2F19%2F%E5%8A%A8%E6%BC%AB%2F%E5%8F%AA%E6%9C%89%E6%88%91%E5%AD%98%E5%9C%A8%E7%9A%84%E8%A1%97%E9%81%93%2F</url>
    <content type="text"><![CDATA[牛仔在看到一部动漫，意外的好看呢。 雏月小时候好萌，唉可惜长大后就不萌了噫。 看到15年后，八代老师推着悟上天台，突然间意识到了自己愤怒，虽然看多套路最后肯定是happy end，八代肯定也会受到制裁，就是不可抑制自己的愤怒。 联想到最近的魏则西事件，突然明白为什么朋友圈那么多人在转（不同于网上的一些网民，朋友圈里的朋友都是上过高等教育的，有很强的辨别能力，也不是听风就是雨的人），大家都感受到了愤怒，需要一个制裁的对象来发泄而已。 之前看过一部电影狩猎，意识真实的情形正在现实中上演，虽然形式不一样，但起因是相同的，大多数人都喜欢站在了道德的制高点，任由自己的愤怒去攻击别人，真相是什么其实他们不是很关心，他们关心的他们制裁的对象有没有被消灭罢了。 相信文革和对日本的看法有很大一部分的原因是由这个造成的吧。 跨过这种愤怒，才能看到真相 我更希望自己能选择原谅 小时候的雏月真的好萌，ヾ(≧O≦)〃最后居然没跟男主在一起。。(好在已经有人给作者寄刀片了。。不过还好也不讨厌广美（。。看完后还不知道是个男孩子）。。其实爱梨也不错，就是名字有点会联想糟糕。。 雏月酱 叽叽叽]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梦魇]]></title>
    <url>%2F2019%2F01%2F19%2F%E8%AE%B0%E4%BA%8B%2F%E6%A2%A6%E9%AD%87%2F</url>
    <content type="text"><![CDATA[下午6点起来发现开了灯还是没亮，又听到有女孩的声音，还听见狗灰叫我去打球。但怎么也走不出自己的房间。 突然意识自己在做梦，但怎么也醒不来]]></content>
      <categories>
        <category>记事</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>梦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F01%2F19%2FAndroid%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[| 或 (grep正则表达式要加 -E) 1$ adb logcat | grep -E "HeadsetStateMachine:| setForceUse"]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git应用补丁]]></title>
    <url>%2F2019%2F01%2F19%2FAndroid%2Fgit%E5%BA%94%E7%94%A8%E8%A1%A5%E4%B8%81%2F</url>
    <content type="text"><![CDATA[注意打补丁的路径 检测你的补丁状况1$ git apply --stat your_fly_sky.patch 查看是否能应用成功1$ git apply --check your_fly_sky.patch 应用patch1$ git am -s &lt; 0001-minor-fix.patch]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深圳故事1]]></title>
    <url>%2F2019%2F01%2F19%2F%E8%AE%B0%E4%BA%8B%2F%E6%B7%B1%E5%9C%B3%E6%95%85%E4%BA%8B1%2F</url>
    <content type="text"><![CDATA[（唉，本想找一下刚来深圳拍的一些照片，结果都在那个被我拆坏的手机里了） 四月过半，离2015的4月快一年了，从那时之后就有各种神奇的事情发生 六月过后，在处理了学校的一些杂事后，我背上吉他来到踏上回广东的道路。记得胖子和zz帮我提行李箱和吉他到楼下，zz还拿我的吉他装了下b，然后就要离开生活了四年的520狗窝，说真的，在520最后的两年，应该是最接近我理想中的生活了，整天懒懒散散的，忙活着自己喜欢的事情，偶尔跟兄弟吃酒喝肉的。最后胖子也就简单的挥挥了手，我就坐上了zz妈妈的车去赶下午的飞机。 到了大巴站后zz和他妈妈帮我指了下大巴站的位置就走了，那时候我突然感到莫名的害怕，刚从象牙塔出来，感觉就像小时候晚上2点骑自行车到海边，进入一段毫无亮光的路段，对未来充满恐惧，还有就是，我不知道大巴站的门在哪里。由于赶不上飞机的担心（其实时间还很多，就是从小都有对时间限制有恐惧感），于是就到处问人，大巴站在哪，问了个保安后找到了一个类似一办事大厅的地方，里面就只有几个人坐着沙发上，也看不出有大巴站的样子，然后我就很郁闷，在那里晃来晃去的，也没找到像样的大巴站的地方。这时几个黑出租司机围了过来，拉着我就说上车上车，我当时就想坐大巴(大巴25块，坐那个黑出租至少要120块，而且我时间很有剩余）直接就回绝了。后来实在找不到，就硬着头皮去办事大厅去问那几个坐在沙发的陕西人，没想到他们也是黑出租司机，也想劝我坐出租车。我直接就不想搭理，想去问打扫厕所的阿姨。被他们这么一搞，我心也有点慌，拖着行李箱想从沙发和桌子中间过去，一不小心就撞到了其中一个人的脚。那人二话不说就踹了我一脚，恶狠狠的用陕西话骂了我几句，让我从另一边过去。那时候离校的心情本来就不是很好，加上找不到大巴站，被骂之后心情差到了极点。狼狈的道歉之后从另一边绕过去找那阿姨。原来大巴站在一个小后门后面，不仔细看都看不出来的。坐上大巴后，满脑子回想着刚才的事情，加上之前对西安这座城市印象不是很好（被偷了几次手机，城市建设不是很好，人的素质也很差）当时就一个想法 ###操他妈西安 坐在大巴上，回想在520的日子，还有刚才受到委屈，听着Dream的时候还能忍着，当歌曲切到Imagining时，眼泪就自己满到眼睛处溢了出来，又怕别人看见，抱着吉他呆呆的望着窗外看了一个多小时。 到机场后就开始飞机大巴出租车不停的换乘，中间好像还去any新那里过了一晚，又在去东莞的大巴上累得睡着了，感觉是很快就到东莞了，具体来说应该是到东莞长安了，后来经历了那些事情，真是 ###操他妈长安对东莞的第一印象就是乱，路边的小摊随便摆，红灯随便闯，最神奇的是车子可以停在路中间，真是去过各个省份各个城市，最多就停在路的旁边，还没见过停在路的中间的。路上跟司机闲聊，司机也是各种吐槽城市管理的混乱，说城管根本就不管着东西，想想也是，城管都去抓小摊小贩去了，管这东西太费神。 出租车左拐右拐，就到了一个无比荒凉的地方，所谓的厂区吧，当时是上班时间，路上空无一人，海风又大，地上时而可以看到卷起的沙跟尘的漩涡，从车上出来的时候，还真有一种大佬出动的感觉。取了吉他和行李之后，就进到一栋前面有Vivo员工宿舍几个大字的大楼报告去了（其实就是对了下照片，写了个电话，领了房间的钥匙和空调的遥控器和遥控器的电池）。坐了一个还没拆装修，味道很重的电梯上7楼去了，找到了自己的房间,清点自己寄过来的书和衣物，鞋子还没脱就睡着了。。 第二天去签合同，300多号人挤在一个会议厅里，每个人每件事都充满新鲜感，后来招我们的hr就发了一份合同跟一个保密协议，然后hr就像老师教学生一样，翻到第几页添什么，什么东西不要填什么的。当时翻来覆去看了几遍，签到时候感觉就像自己把自己买了一样。后面又每个人发了个手机，我记得是有两种的，一个是x3l，一个是x5，有人领到x5很兴奋，我领到的x3l，长得一样，又不是自己的到时还得还回去，觉得没什么所谓。 之后的几天每天早上有班车拉我们去一个酒店上课，就是有人在上面讲ppt，你坐在下面听边听边记，身为在学校挂科到差点毕不了业的学渣，自然是直接无视每天睡觉。讲的都是些公司文化，包括公司前身啊，发展战略啊，创始人的故事，还有各个部门的介绍，还有一节请外面的讲的职业发展课。或许就是在那时的态度埋下的祸根，导致了后面一连串事情的发生。 在酒店上课其实挺无聊的，习惯了学校自由懒散的生活，突然又像小学生坐着上课让我很不适应，没事就玩手机，刚开始跟其他人不熟，又是不同组的人做在一起，更没事话说。一天的生活就是从宿舍到酒店上课，中午坐在地上睡觉（酒店的大厅躺满了人，很能反应当时行尸走肉的状态），晚上回去弹会儿吉他，扫扫地，洗洗衣服就睡觉了。当时每个人都有自己的一个房间，基本上每个人回去都锁门着门，也不知道他们在干什么，那时候我还很期待有人过来串门的，就故意把门开着，选几首最吵到歌的弹，不过到最后也没有人过来。 上课上了有一周多，开始有组织一些活动，有一些很无聊的团队游戏，像一队人去猜牌，接球比赛啊，坐大腿成一个环形啊等等，不过比上课好玩多了，还有自我介绍，每个人要记住队里所有人名字，所以每个人都去问别人的名字，当时就没怎么记住，后来自然基本上都忘。当时还对一个女生挺有好感的，她说叫她老何就行，也是沉默很少说话，很喜欢她说话的声音来着，做游戏还乘乱牵她的手来着。坐着闲聊的时候，有人问我指甲为什么留这么长，我告诉他我有在练吉他啦，他说看到指甲这么长感觉很恐怖，建议我去剪掉。 关于吉他，还有一些事情，一开始我就在qq群里找有没有一起学吉他的，后来只有一个人过来找我，在上课休息的某一天中午（热得要死），我拖着吉他，过去他宿舍找他，招了辆摩的，他跟我说在那里的大排档有个彩虹乐队，每天晚上可热闹啦，唱一整晚，想想也不错。过去之后跟学吉他的一起唱，他有一只面单的yamaha，音质要比我那不知名的吉他要好，一起唱了beyond的，许巍，还有一些其他乱七八糟的歌，感觉他唱歌比我要好很多（其实我是因为唱歌不好才转指弹的，要是唱得好的话，早就出名了，我一直是这样想的），感觉还很不错，当时就想再找一个唱歌唱得更好的来做主唱，我们来伴奏，在这次培训结束后唱许巍的故乡。 在那之后我就每天的练那首歌，主要是练前奏和节奏的，平时也是没事有事就听那首歌，特别是回去的时候经常坐在阳台听这首歌看宝安机场的飞机飞来飞去，当时也没什么朋友，感觉十分适合当时的孤独心境。之后还用那个x3l录了练了很久团子，用每秒23kb的速度传到了b站上，感觉指弹需要一把好一点的吉他，又向二姐接了2000多块卖了一把syain yd25 这估计是我到现在买的最贵的东西了。 上课上到最后，几个部门的部长上去讲，当时也是各种奇葩都有，有一个讲着讲着就扯到社会的制度有问题，然后就大谈他对这个社会的看法，讲得我当时心里特别扭。还有一个讲工厂安全的，给我们放车撞死人的视频，看人体被车各种碾碎，各种撞飞，都没打码，看得我阵阵的胃疼。其他的大部分基本讲很无聊（比之前上课还无聊，毕竟让程序员去讲这个简直了），也有很少讲得很精彩的，说他之前（也）环境更荒凉，出门没事干，只能在阳台上看飞机，他说他之前在互联网公司呆过，可能思维跟我更接近吧。 培训的最后是一次集体出游，到深圳大梅沙穿越东西冲（就是走海滩啦）。看到老何穿着清凉的夏装（好像还有顶遮阳帽），感觉很是心动的，当时还打算去追追看有没有机会，总之那天天气很好，心情也很不错，毕竟回来的原因之一就是能看到大海吗。跟坐在旁边的QE胖子也熟络起来，没事就聊一聊广东这边的吃的和美女，不过他也认为我不是很爱说话，属于闷骚型的。总之那天还脱了袜子去海边玩，有好些人都是第一次看见大海很是兴奋，最后还在沙滩上用沙堆了个vivo字样，几百好人拍了一个脸都看不清的大合照。 出游后情况就急转直下，因为培训后还有一场考试，考不过作开除处理，内容就是上课的东西，之前上课也有说过考试的重点，甚至在考试前还有像大学考试一样前届考试题。当时的想法就是一方面是“shit，工作也考这种鬼东西，老子不干了”，另一方面就是“shit，应该比大学考试简单吧，水一水就过了”，因为大学选错专业的缘故，考试让我极其痛苦，我对这种考试已经不能用厌恶来形容了，导致大学四年基本靠自学，感兴趣的就考得特别好，不感兴趣的基本就飘过或补过。那天晚上背了两三道题之后就去练吉他去了。 第二天早上起来还挺有信心的，看看题目都能答出个意思出来，根据以往大学的经验，带上小抄，再抄点别人的基本就能保证万无一失，最少也有55+，（大学55+基本都会改成60分给过的，这在西电是默认的规则） 考试的时候在工厂的食堂，还是比较严格的，要间隔个人坐，手机关机等，还有很寻考。不过到后面还是对抄来抄去睁一只眼闭一只眼的。开始考试之前我还在背，我们组有一个比较活跃的女生还老来跟我聊天，还老说会不会打扰你啊，让你考不过怎么办啊，唉～。 考的时候第一道题就是公司的企业文化，我当然知道第一就是本分，阿段提出的个人与企业在商场安身立命的准则之一。我对这个也很理解，潮汕文化经商准则第一条也应该诚信等，说白了就是做人要诚信厚道。所以当时就想本分一会吧，企业文化核心都不遵守，在这公司待着也就是混日子。于是想求低分飘过，小抄没用上，也没参考别人答案。在那里把能答的都答上来，就像初中写政治题一样，把卷子写得满满的，想阅卷人看在这诚意上也能给过吧，在那里呆到基本最后人都走光了才交卷。 当天晚上，负责考试的hr就在群里说有几个不及格的，情况的比较严重，心里就咯噔一下，按以往的直觉自己是跑不了了（不知道为啥对自己会遭遇不幸的自觉一般很准的），当天整夜睡不着。第二天打电话给二姐的时候，二姐还老安慰没事的啦。考试后公司安排我们到厂里实习（搬搬东西，拧拧螺丝），感觉节奏就变了，拧了一整天的螺丝，感觉变得麻木了，也就不那么担心了。（其间还叫一个小胖妹做师傅，因为一开始不会做，她又不怎么理我，想缓和下气氛,不过之后好像更尴尬，现在想起来都觉得。。唉～） 第三天hr就开始找我们谈话，把我在内的四个人从工厂叫到总部去，当时神经又紧绷起来，当时还想应该只是给点惩罚吧，因为不相信公司会因为这样一个考试而开除人。谈话是一个人一个人进行的，我记得我当时还是比较紧张的，除了负责考试的hr，还有一个应该是hr头的人。头翻了我的试卷，又翻了我之前的笔试试卷和简历后，沉默了许久，说了句“你笔试成绩也很低，你的面试官是谁”。我顿时就紧张得说不出话来，因为我是面试给面试官看了之前做的作品，还有大概讲了实习经历及对手机行业的看法，然后就直接给过（去招的时候对自己的实力还是有自信的，笔试一般会答个一般水平就能过，而且我都不知到我笔试成绩多少），还有我对人名很难记住。又沉默了许久跟他说我忘了，看了一下笔试试卷70几分，又一阵难熬的沉默后跟他说因为自己不擅长考试。然后负责考试的hr又问了一句你觉得你在公司的优势是什么，这时候紧张的连汗都流出来了，从牙缝里挤出声音说觉得自己实力还行，学习适应能也还可以。后面又说为什么别人基本都是90多你为什么不及格，当时我心里就真是日了狗，那么多人抄来抄去当然都是90多啊，但又不能明说，只能又说自己不善考试，又明说了自己在学校也是这样，又说企业文化要在企业工作慢慢体会吸收，不能仅凭考试来判定一个人，后面扯什么也都忘了，最后让我会宿舍呆着，晕晕的出来之后出来发现跟我一起来的三个人都不见了，就自己走回宿舍躺着。 回到宿舍后躺在床上望着天花板，心里什么滋味也不是。想着自己从北京跑回来的意义，想想被赶出去该怎么办，想想为什么会变成这个样子，总之想了很多。爬起来弹了会吉他，又跑去蹲厕所，那时候就想着有根烟抽有多好啊。熬到晚上六点，有人来敲我的门，我知道不是其他人，因为工厂要7点半才下班，肯定是其他三个人，开门是一个小胖和跟我同部门的张，之前我都不知到他跟我同部门，或者说都不知道有这么一个人。他们也很紧张，我们交流一些面谈的信息后，知道了情况的确很严重，有可能几个人都会被开。张还比较乐观，也是觉得应该只是给点惩罚措施吧，小胖就一直叨唠完了完了，说他面谈很糟糕，如果四个人中挑几个人被开也应该是他，跟他们谈话也了解到，负责考试的hr是我们西电学长，还有两个其他部门的也是我们这种情况 后面怎么谈也猜不出公司会怎么做，就去找了另外一个胡去一起吃了午饭，还要了几瓶酒，商量以后如果出现最糟糕的结果，我们该怎么办，还讲了自己的家庭状况，聊了些别的，喝了点酒后心情好些了，想想被开就开也好，至少不用整天像个机器人一样在工厂工作了，想一些有点没的，也就渐渐的睡着了。 第二天早上醒来，联系了其他三人，说好了一起过去工厂，虽然hr没说要不要去工厂了，但我们还是觉的去为好，其他人还不知道我们的情况，让其他人知道我们考不及格也很丢脸，（经过了昨天的面谈我们四个感情突然变得很好）然后我们四个人就一起去了工厂。到了工厂小胖妹还没来，我就跟旁边工位的另一个小女孩聊天，问她叫什么名字，一开始还跟我嘟囔四川话，看我听不懂，又用普通话，原来她叫徐静，是四川那边一所职业学校，比我小了7、8岁过来。然后我低声跟她说明天可能见不到我了，她很惊讶的问我为什么啊，我跟她说因为考试不及格，她说不会的，一般有补考的。我叹了口气说，也许吧。 到了下午，工头说hr过来工厂找我们，让我们不用做了过去谈话，想着该来的总会来的，看了徐静一眼，就跟他们三个下楼去等hr了。那时候大家都心里有底了，小胖还老是说自己肯定被开了，你们还有机会，我心想机会个屁啊都这样了，张也脸色也不好，说要去拿试卷，打算做最后的一搏。 面谈的时候小胖第一个，很快就出来了，面无表情看了我们一眼，说在外面等我们，张第二进去的，他比较能说的，进去了很久，胡和我在外面等，胡抓着手指说他过来时放弃了一个更好的机会，我看着他也不知道说什么，就用我实习面试的经历去安慰他（实习面试经历也是十分痛苦，有机会会写出来的），说经历点风浪总是好的。不过他还是一直一直都抓着手指。。 第三个是我还是胡忘了，进去之后hr学长机械的通知他们已经按照流程做开除决定，又机械的说了一些安慰的话，然后hr boss就问我还有什么要说的吗，我点点头，跟他要了试卷，一句话没说就走了。 那天晚上四个人去喝酒，张还老取笑小胖胆小，大家都看开了，喝了很多，也许是放下了，大家心情还不错就开始计划下一步该怎么走，张说要不是因为这个破事，我都不知道你们这些人，缘分啊！干杯！还讨论开除我们会对其他人有什么影响，讨论来讨论去，得出来结论就是大家应该都会把我们忘了吧，当时也没怎么伤心，忘了更好哈哈哈，然后几个人醉醺的回去了（哈，好像也没多醉醺），反正当时心情也舒畅很多。 回到宿舍，厂里的QE小胖貌似知道我们的事了，发微信来确认，还安慰我一顿，说临走前希望跟我吃顿饭（当时还是有点感动的），学吉他的小哥也表示很遗憾，（不过那是几天后的事了） 考完试的第四天，我们就拿到离职通知书，然后让我们去归还机器，给我们7天的时间让我们搬走，后来又发生了很多事情，不过那个又是另外一个故事的开始了。。 PS.现在看来，当时也不知道谁对的谁错的，因为公司有规定，他们那样做也无可厚非，只是总有些不合理的地方造成了这种状况。不管怎么样，过去就过去了，谁是谁非不是很想追究的，但故事还是值得留恋的。]]></content>
      <categories>
        <category>记事</category>
      </categories>
      <tags>
        <tag>故事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[client与AudioFlinger的数据交换]]></title>
    <url>%2F2019%2F01%2F19%2FAndroid_Audio%2Fclient%E4%B8%8EAudioFlinger%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[AudioTrack与AudioFlinger在两个不同进程，他们之间要通过共享内存进行音频的数据交换。交换的实现通过环形缓冲去来实现，貌似没有同步机制，从实验结果来看，AudioTrack写满缓冲区后AudioFlinger就会去读取。 数据交换的实现主要在AudioTrackShared.cpp中实现，包括AudioTrackClientProxy和AudioTrackServerProxy。 两边数据通过cblk的flag来进行数据的读写。 1234567891011121314151617181920212223//两边操作数据的接口class Proxy : public RefBase &#123; ...public: struct Buffer &#123; size_t mFrameCount; // number of frames available in this buffer void* mRaw; // pointer to first frame size_t mNonContig; // number of additional non-contiguous frames available &#125;;protected: // 共享内存的一些信息 audio_track_cblk_t* const mCblk; // the control block void* const mBuffers; // starting address of buffers const size_t mFrameCount; // not necessarily a power of 2 const size_t mFrameSize; // in bytes const size_t mFrameCountP2; // mFrameCount rounded to power of 2, streaming mode const bool mIsOut; // true for AudioTrack, false for AudioRecord const bool mClientInServer; // true for OutputTrack, false for AudioTrack &amp; AudioRecord bool mIsShutdown; // latch set to true when shared memory corruption detected size_t mUnreleased; // unreleased frames remaining from most recent obtainBuffer&#125;; 客户端的流程:获取Buffer -&gt; 填充数据 -&gt; 释放Buffer12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//获取Buffer在obtainBuffer中实现，里面还有一些关于获取失败的等待方式的一些东西 //cblk的buffer通过rear和front，通过log可以看出rear和front都是增长的，rear - front就是填充了数据的缓冲区，怎么映射到buffer上还要再看。status_t ClientProxy::obtainBuffer(Buffer* buffer, const struct timespec *requested, struct timespec *elapsed)&#123; //time的初始化 // 几种Timeout方式 enum &#123; TIMEOUT_ZERO, // requested == NULL || *requested == 0 TIMEOUT_INFINITE, // *requested == infinity TIMEOUT_FINITE, // 0 &lt; *requested &lt; infinity TIMEOUT_CONTINUE, // additional chances after TIMEOUT_FINITE &#125; timeout; // 一个死循环来获取Buffer，通过break和goto end来实现不同的Timeout for (;;) &#123; // ...(检查cblk的flag) // compute number of frames available to write (AudioTrack) or read (AudioRecord) int32_t front; int32_t rear; if (mIsOut) &#123; // ...(这里有一大段注释，说android_atomic_acquire_load可能是无用的，但就是要加，就是要任性..) front = android_atomic_acquire_load(&amp;cblk-&gt;u.mStreaming.mFront); rear = cblk-&gt;u.mStreaming.mRear; &#125; else &#123; rear = android_atomic_acquire_load(&amp;cblk-&gt;u.mStreaming.mRear); front = cblk-&gt;u.mStreaming.mFront; &#125; // 获取填充数据的buffer ssize_t filled = rear - front; // pipe should not be overfull if (!(0 &lt;= filled &amp;&amp; (size_t) filled &lt;= mFrameCount)) &#123; // ...(gg了) &#125; // 获取可以利用的空间 size_t avail = mIsOut ? mFrameCount - filled : filled; if (avail &gt; 0) &#123; // 'avail' may be non-contiguous, so return only the first contiguous chunk // 这里要处理的是这种情况，像如下的buffer(*是数据) // __________**********__________ // 获取到avail是两边空白的和，这里只能要一边 // ... // 获取到了buffer，走人 status = NO_ERROR; break; &#125; // ...(后面是avail等于0的情况,有可能是server那边没读完，也有可能其他情况,根据不同的Timeout方式选择等待或放弃) &#125;end: // ...(错误处理等)&#125;//填充数据没有特殊的api，一般用memcpy就可以了memcpy(audioBuffer.i8, buffer, toWrite);buffer = ((const char *) buffer) + toWrite;userSize -= toWrite;written += toWrite;// 释放数据很简单void ClientProxy::releaseBuffer(Buffer* buffer)&#123; // ...(参数检查，避免释放不合法的buffer mUnreleased -= stepCount; audio_track_cblk_t* cblk = mCblk; // 其实就只改了一个指针 if (mIsOut) &#123; int32_t rear = cblk-&gt;u.mStreaming.mRear; android_atomic_release_store(stepCount + rear, &amp;cblk-&gt;u.mStreaming.mRear); &#125; else &#123; int32_t front = cblk-&gt;u.mStreaming.mFront; android_atomic_release_store(stepCount + front, &amp;cblk-&gt;u.mStreaming.mFront); &#125;&#125; 服务端也是差不多的流程:获取Buffer -&gt; 使用数据 -&gt; 释放Buffer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//获取Buffer在obtainBuffer中实现，方式跟客户端的差不多status_t ServerProxy::obtainBuffer(Buffer* buffer, bool ackFlush)&#123; // ...(参数检查，避免buffer为空等) if (mIsOut) &#123; int32_t flush = cblk-&gt;u.mStreaming.mFlush; rear = android_atomic_acquire_load(&amp;cblk-&gt;u.mStreaming.mRear); front = cblk-&gt;u.mStreaming.mFront; if (flush != mFlush) &#123; // effectively obtain then release whatever is in the buffer // Note:这里有一大段修正Front的 不知在干吗 &#125; &#125; else &#123; front = android_atomic_acquire_load(&amp;cblk-&gt;u.mStreaming.mFront); rear = cblk-&gt;u.mStreaming.mRear; &#125; // 计算客户端填了多少数据 size_t availToServer; if (mIsOut) &#123; availToServer = filled; mAvailToClient = mFrameCount - filled; &#125; else &#123; availToServer = mFrameCount - filled; mAvailToClient = filled; &#125; // 'availToServer' may be non-contiguous, so return only the first contiguous chunk // ...(这里跟客户端一样也有是去左右其中一段)no_init: // ...(错误处理)&#125;// 服务端使用数据场景比较复杂，主要是混音跟重采样比较麻烦// obtainBuffer被分装在Track(AudioFlinger的一个内部类)的getNextBuffer中// DirectOutputThread中使用跟客户端差不多，也是直接写memcpy(curBuf, buffer.raw, buffer.frameCount * mFrameSize);frameCount -= buffer.frameCount;curBuf += buffer.frameCount * mFrameSize;// 其他的基本都是在AudioMixer中被使用，// 比如重采样，hook是一个函数指针，根据配置会选择不同的采样函数t.bufferProvider-&gt;getNextBuffer(&amp;t.buffer, outputPTS);t.hook(&amp;t, outTemp + outFrames * t.mMixerChannelCount, t.buffer.frameCount, state-&gt;resampleTemp, aux);// 比如混音t.bufferProvider-&gt;getNextBuffer(&amp;b, outputPTS);const int16_t *in = b.i16;do &#123; uint32_t rl = *reinterpret_cast&lt;const uint32_t *&gt;(in); in += 2; int32_t l = mulRL(1, rl, vrl) &gt;&gt; 12; int32_t r = mulRL(0, rl, vrl) &gt;&gt; 12; // clamping... l = clamp16(l); r = clamp16(r); *out++ = (r&lt;&lt;16) | (l &amp; 0xFFFF);&#125; while (--outFrames);// 释放Buffer也比较简单void ServerProxy::releaseBuffer(Buffer* buffer)&#123; // ...(参数检查) // 基本跟客户端一样 if (mIsOut) &#123; int32_t front = cblk-&gt;u.mStreaming.mFront; android_atomic_release_store(stepCount + front, &amp;cblk-&gt;u.mStreaming.mFront); &#125; else &#123; int32_t rear = cblk-&gt;u.mStreaming.mRear; android_atomic_release_store(stepCount + rear, &amp;cblk-&gt;u.mStreaming.mRear); &#125; // 唤醒客户端 // ...(各种参数的计算) if (!(old &amp; CBLK_FUTEX_WAKE)) &#123; (void) syscall(__NR_futex, &amp;cblk-&gt;mFutex, mClientInServer ? FUTEX_WAKE_PRIVATE : FUTEX_WAKE, 1); &#125; // ...(清空buffer)&#125; 这里仅仅是数据的交换流程，具体控制在Track里，Track的各种状态都会影响改流程的。]]></content>
      <categories>
        <category>Android_Audio</category>
      </categories>
      <tags>
        <tag>framework</tag>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Audio调节音量流程]]></title>
    <url>%2F2019%2F01%2F19%2FAndroid_Audio%2FAudio%E8%B0%83%E8%8A%82%E9%9F%B3%E9%87%8F%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Audio音量调节是一级一级调节，而且分不同的流类型，如响铃，通话，多媒体等。不同的设备(蓝牙设备)的设置方法有所区别。 sdk的api，设置相应流的音量。不同的流index的范围不一样12345678910//---&gt;frameworks/base/media/java/android/media/AudioManager.javapublic void setStreamVolume(int streamType, int index, int flags) &#123; IAudioService service = getService(); try &#123; service.setStreamVolume(streamType, index, flags, getContext().getOpPackageName()); &#125; catch (RemoteException e) &#123; Log.e(TAG, "Dead object in setStreamVolume", e); &#125;&#125; java层Service实现,volume的调节的实现是用state模式来实现，可能需要原子性或不同的模式下调节音量的操作不同。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//---&gt;frameworks/base/services/core/java/com/android/server/audio/AudioService.javaprivate void setStreamVolume(int streamType, int index, int flags, String callingPackage,String caller, int uid) &#123; // ...(检查参数) // ...(转换参数) // 获取设备 final int device = getDeviceForStream(streamType); // ...(特殊处理a2dp) // ...(检查uid，实体按键调节音量需要判断当前用户？) synchronized (mSafeMediaVolumeState) &#123; mPendingVolumeCommand = null; oldIndex = streamState.getIndex(device); index = rescaleIndex(index * 10, streamType, streamTypeAlias); // ...(特殊处理a2dp) // ...(特殊处理HDMI) // ...(设置一些标志位，如标记一些不可调节音量的设备) //检查当前是否可设置音量 if (!checkSafeMediaVolume(streamTypeAlias, index, device)) &#123; // 不可以则生成PendingCommand，等待合适的时机 mVolumeController.postDisplaySafeVolumeWarning(flags); mPendingVolumeCommand = new StreamVolumeCommand( streamType, index, flags, device); &#125; else &#123; // 设置音量 onSetStreamVolume(streamType, index, flags, device, caller); index = mStreamStates[streamType].getIndex(device); &#125; &#125; // 发送更新音量信息 sendVolumeUpdate(streamType, oldIndex, index, flags);&#125;private void onSetStreamVolume(int streamType, int index, int flags, int device,String caller) &#123; final int stream = mStreamVolumeAlias[streamType]; // 设置音量 setStreamVolumeInt(stream, index, device, false, caller); // ...(判断音量是否为0，调节模式(静音或响铃)) mStreamStates[stream].mute(index == 0);&#125;private void setStreamVolumeInt(int streamType,int index,int device, boolean force,String caller) &#123; VolumeStreamState streamState = mStreamStates[streamType]; if (streamState.setIndex(index, device, caller) || force) &#123; // Post message to set system volume (it in turn will post a message // to persist). sendMsg(mAudioHandler,MSG_SET_DEVICE_VOLUME,SENDMSG_QUEUE,device, 0,streamState,0); &#125;&#125; @Overridepublic void handleMessage(Message msg) &#123; // ... switch (msg.what) &#123; case MSG_SET_DEVICE_VOLUME: setDeviceVolume((VolumeStreamState) msg.obj, msg.arg1); break; // ... &#125; // ...&#125;private void setDeviceVolume(VolumeStreamState streamState, int device) &#123; synchronized (VolumeStreamState.class) &#123; // 设置音量 streamState.applyDeviceVolume_syncVSS(device); // ...(Apply change to all streams using this one as alias) &#125; // Post a persist volume msg sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,SENDMSG_QUEUE,device,0, streamState,PERSIST_DELAY);&#125;public void applyDeviceVolume_syncVSS(int device) &#123; int index; if (mIsMuted) &#123; index = 0; &#125; else if (((device &amp; AudioSystem.DEVICE_OUT_ALL_A2DP) != 0 &amp;&amp; mAvrcpAbsVolSupported) || ((device &amp; mFullVolumeDevices) != 0)) &#123; index = (mIndexMax + 5)/10; &#125; else &#123; index = (getIndex(device) + 5)/10; &#125; AudioSystem.setStreamVolumeIndex(mStreamType, index, device);&#125; AudioSystem的setStreamVolumeIndex是个native函数，从这里到跳到c++代码12//---&gt;frameworks/base/media/java/android/media/AudioSystem.javapublic static native int setStreamVolumeIndex(int stream, int index,int device); jni的代码没做处理，直接转发给c++层的AudioSystem1234567891011//---&gt;frameworks/base/core/jni/android_media_AudioSystem.cppstatic JNINativeMethod gMethods[] = &#123; ... &#123;"setStreamVolumeIndex","(III)I", (void *)android_media_AudioSystem_setStreamVolumeIndex&#125;,...&#125;;static jint android_media_AudioSystem_setStreamVolumeIndex( JNIEnv *env,jobject thiz,jint stream,jint index,jint device)&#123; return (jint) check_AudioSystem_Command(AudioSystem::setStreamVolumeIndex( static_cast &lt;audio_stream_type_t&gt;(stream),index,(audio_devices_t)device));&#125; AudioSystem又踢给AudioPolicyService(这里是binder通信，从这里跳到服务端处理)12345678//---&gt;frameworks/av/media/libmedia/AudioSystem.cppstatus_t AudioSystem::setStreamVolumeIndex(audio_stream_type_t stream, int index,audio_devices_t device)&#123; const sp&lt;IAudioPolicyService&gt;&amp; aps = AudioSystem::get_audio_policy_service(); if (aps == 0) return PERMISSION_DENIED; return aps-&gt;setStreamVolumeIndex(stream, index, device);&#125; AudioPolicyService做了些权限和参数检查，转发给AudioPolicyManager12345678910//---frameworks/av/services/audiopolicy/service/AudioPolicyService.cppstatus_t AudioPolicyService::setStreamVolumeIndex(audio_stream_type_t stream, int index,audio_devices_t device)&#123; if (mAudioPolicyManager == NULL) return NO_INIT; if (!settingsAllowed()) return PERMISSION_DENIED; if (uint32_t(stream) &gt;= AUDIO_STREAM_PUBLIC_CNT) return BAD_VALUE; Mutex::Autolock _l(mLock); return mAudioPolicyManager-&gt;setStreamVolumeIndex(stream,index,device);&#125; AudioPolicyManager的处理比较复杂，主要是包括了音频策略的判断123456789101112131415161718192021222324252627282930313233343536//---&gt;frameworks/av/services/audiopolicy/managerdefault/AudioPolicyManager.cppstatus_t AudioPolicyManager::setStreamVolumeIndex(audio_stream_type_t stream, int index,audio_devices_t device)&#123; // ...(检查音量及设备是否为audio设备) // ...(策略判断) if ((device != AUDIO_DEVICE_OUT_DEFAULT) &amp;&amp; (device &amp; (strategyDevice | accessibilityDevice)) == 0) &#123; return NO_ERROR; &#125; // ...(设置每个输出设备的音量) status_t volStatus = checkAndSetVolume(stream, index, desc, curDevice); // ...&#125;status_t AudioPolicyManager::checkAndSetVolume(audio_stream_type_t stream,int index, const sp&lt;AudioOutputDescriptor&gt;&amp; outputDesc,audio_devices_t device,int delayMs,bool force)&#123; // ...(do not change actual stream volume if the stream is muted) // ...(do not change in call volume if bluetooth is connected and vice versa) // 声音等级与真正参数的转换 float volumeDb = computeVolume(stream, index, device); // 设置输出设备的声音 outputDesc-&gt;setVolume(volumeDb, stream, device, delayMs, force); // 设置通话的音量？？ if (stream == AUDIO_STREAM_VOICE_CALL || stream == AUDIO_STREAM_BLUETOOTH_SCO) &#123; // ... mpClientInterface-&gt;setVoiceVolume(voiceVolume, delayMs); // ... &#125; return NO_ERROR;&#125; AudioOutputDescriptor是音频设备描述符，outputDesc是SwAudioOutputDescriptor类型。123456789101112131415161718192021222324252627282930313233//---&gt;/frameworks/av/services/audiopolicy/common/managerdefinitions/src/AudioOutputDescriptor.cpp bool AudioOutputDescriptor::setVolume(float volume,audio_stream_type_t stream, audio_devices_t device __unused,uint32_t delayMs,bool force)&#123; // We actually change the volume if: // - the float value returned by computeVolume() changed // - the force flag is set if (volume != mCurVolume[stream] || force) &#123; ALOGV("setVolume() for stream %d, volume %f, delay %d", stream, volume, delayMs); mCurVolume[stream] = volume; return true; &#125; return false;&#125;bool SwAudioOutputDescriptor::setVolume(float volume,audio_stream_type_t stream, audio_devices_t device,uint32_t delayMs,bool force)&#123; bool changed = AudioOutputDescriptor::setVolume(volume, stream, device, delayMs, force); if (changed) &#123; // Force VOICE_CALL to track BLUETOOTH_SCO stream volume when bluetooth audio is // enabled float volume = Volume::DbToAmpl(mCurVolume[stream]); if (stream == AUDIO_STREAM_BLUETOOTH_SCO) &#123; mClientInterface-&gt;setStreamVolume(AUDIO_STREAM_VOICE_CALL, volume, mIoHandle, delayMs); &#125; mClientInterface-&gt;setStreamVolume(stream, volume, mIoHandle, delayMs); &#125; return changed;&#125; AudioOutputDescriptor的mClientInterface是AudioPolicyService，所以会转到AudioPolicyService的setStreamVolumeAudioPolicyService异步执行这个操作,最后会转到AudioSystem的setStreamVolume。12345678910111213141516171819202122232425262728293031323334353637//---&gt;frameworks/av/services/audiopolicy/service/AudioPolicyService.cppint AudioPolicyService::setStreamVolume(audio_stream_type_t stream,float volume, audio_io_handle_t output,int delayMs)&#123; return (int)mAudioCommandThread-&gt;volumeCommand(stream, volume,output, delayMs);&#125;status_t AudioPolicyService::AudioCommandThread::volumeCommand(audio_stream_type_t stream, float volume,audio_io_handle_t output,int delayMs)&#123; // ...(封装了一下data跟command) return sendCommand(command, delayMs);&#125;status_t AudioPolicyService::AudioCommandThread::sendCommand(sp&lt;AudioCommand&gt;&amp; command, int delayMs) &#123; // ...(一些命令队列的操作)&#125;// 处理函数bool AudioPolicyService::AudioCommandThread::threadLoop()&#123; // ... while (!exitPending()) &#123; // ... switch (command-&gt;mCommand) &#123; // ... case SET_VOLUME: // ...(Lock) VolumeData *data = (VolumeData *)command-&gt;mParam.get(); command-&gt;mStatus = AudioSystem::setStreamVolume(data-&gt;mStream, data-&gt;mVolume,data-&gt;mIO); break; // ... &#125;&#125; AudioSystem又转到AudioFlinger123456789101112131415161718192021222324252627282930313233//---&gt;frameworks/av/media/libmedia/AudioSystem.cpp status_t AudioSystem::setStreamVolume(audio_stream_type_t stream, float value, audio_io_handle_t output)&#123; // ...(权限参数检查) af-&gt;setStreamVolume(stream, value, output); return NO_ERROR;&#125;AudioFlinger会去获取output对应的PlaybackThread并设置PlaybackThread的音量，如果output == AUDIO_IO_HANDLE_NONE，则设置所有PlaybackThread的音量。//---&gt;frameworks/av/services/audioflinger/AudioFlinger.cppstatus_t AudioFlinger::setStreamVolume(audio_stream_type_t stream, float value, audio_io_handle_t output)&#123; // ...(权限检查) // ...(流类型检查) AutoMutex lock(mLock); // ...(获取对应设备的PlaybackTread) // ??? mStreamTypes[stream].volume = value; if (thread == NULL) &#123; // output == AUDIO_IO_HANDLE_NONE for (size_t i = 0; i &lt; mPlaybackThreads.size(); i++) &#123; mPlaybackThreads.valueAt(i)-&gt;setStreamVolume(stream, value); &#125; &#125; else &#123; thread-&gt;setStreamVolume(stream, value); &#125; return NO_ERROR;&#125; PlaybackThread设置mStreamTypes的volume。并唤醒PlaybackThread线程123456void AudioFlinger::PlaybackThread::setStreamVolume(audio_stream_type_t stream, float value)&#123; Mutex::Autolock _l(mLock); mStreamTypes[stream].volume = value; broadcast_l();&#125; 不同类型的Thread貌似有不同使用方法 MixerThread是在prepareTracks_l里使用，最后会设置AudioMixer的参数123456789101112131415161718192021222324252627//---&gt;frameworks/av/services/audioflinger/Threads.cppAudioFlinger::PlaybackThread::mixer_state AudioFlinger::MixerThread::prepareTracks_l( Vector&lt; sp&lt;Track&gt; &gt; *tracksToRemove) &#123; // ... // FastTrack track-&gt;mCachedVolume = masterVolume * mStreamTypes[track-&gt;streamType()].volume; // ... // NormalTrack // 这里涉及到了左右声道的音量的计算 // compute volume for this track uint32_t vl, vr; // in U8.24 integer format float vlf, vrf, vaf; // in [0.0, 1.0] float format float typeVolume = mStreamTypes[track-&gt;streamType()].volume; float v = masterVolume * typeVolume; // ... //计算完设置混音器的参数 mAudioMixer-&gt;setParameter(name, param, AudioMixer::VOLUME0, &amp;vlf); mAudioMixer-&gt;setParameter(name, param, AudioMixer::VOLUME1, &amp;vrf); mAudioMixer-&gt;setParameter(name, param, AudioMixer::AUXLEVEL, &amp;vaf); // ...&#125;// 最后会调用到mAudioMixer的setVolumeRampVariablesstatic inline bool setVolumeRampVariables(float newVolume, int32_t ramp, int16_t *pIntSetVolume, int32_t *pIntPrevVolume, int32_t *pIntVolumeInc, float *pSetVolume, float *pPrevVolume, float *pVolumeInc)&#123;...&#125; DirectOutputThread在processVolume_l里使用(processVolume_l在prepareTracks_l中被调用)processVolume_l直接设置了输出设备的volume12345678910//---&gt;frameworks/av/services/audioflinger/Threads.cpp void AudioFlinger::DirectOutputThread::processVolume_l(Track *track, bool lastTrack) &#123; ... float typeVolume = mStreamTypes[track-&gt;streamType()].volume; float v = mMasterVolume * typeVolume; // ...(一系列的设置) if (mOutput-&gt;stream-&gt;set_volume) &#123; mOutput-&gt;stream-&gt;set_volume(mOutput-&gt;stream, left, right); &#125;&#125; 还有其他的几种Thread都是上面两种Thread的子类，处理方式是一致的]]></content>
      <categories>
        <category>Android_Audio</category>
      </categories>
      <tags>
        <tag>framework</tag>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公司年会]]></title>
    <url>%2F2019%2F01%2F19%2F%E8%AE%B0%E4%BA%8B%2F%E5%85%AC%E5%8F%B8%E5%B9%B4%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[公司年会很热闹，玩得也挺开心的，节目表演得中规中居，感觉也没什么特色，最想要的x没有抽到，却抽到了5k，还是一如即往的想要啥没啥，没有什么期待的却老是有 (:3 」∠) 中奖之后也没有想象中的那么开心，但也没有不开心，就像往常一样嘛，没什么期待(我倒希望中个x） 还是很怀念大学的那段堕落的日子，每天无所事事，写个喜欢的app，挣点小钱，不想写了就不写，拿了钱跟舍友一起去吃饭，喝酒喝到吐。也许那就是最理想的状态了。 时光在流逝，嚷嚷红尘，你该何去何从。]]></content>
      <categories>
        <category>记事</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[audio 混音]]></title>
    <url>%2F2019%2F01%2F19%2FAndroid_Audio%2Faudio-%E6%B7%B7%E9%9F%B3%2F</url>
    <content type="text"><![CDATA[android的混音是通过AudioMixer来实现的，最近遇到了一个混音的问题，该是好好看看音频的基本知识了。 音频的基本知识很早之前就知道音频存储是通过采样来实现的，就是所谓的A/D（Analog-to-Digital Converter与D/A（Digital Analog Converter）音轨有很多属性如 采样率(sampleRate) 编码格式(format) 通道(channelCount) 总帧数(frameCount) ? 音量(volume) ? 播放速率(playbackRate) ? 前三个比较重要，具体去了解一下 采样率看到知乎上有一个回答，感觉挺形象的–什么是音频的采样率？采样率和音质有没有关系？ 一般的采样率固定在44100HZ(- -就是一秒记44100次)，理由是因为人耳听觉范围在20HZ~20KHZ，这样记录能还原最高22.05KHZ的声音还有一个采样率 48000HZ 也比较常见 编码格式指每次采样所用的bit数，比如8bit，16bit从命名来看，android好像用来8bit，16bit跟32bit AUDIO_FORMAT_PCM_16_BIT AUDIO_FORMAT_PCM_8_BIT AUDIO_FORMAT_PCM_32_BIT AUDIO_FORMAT_PCM_8_24_BIT AUDIO_FORMAT_PCM_FLOAT AUDIO_FORMAT_PCM_16_BIT_OFFLOAD ? AUDIO_FORMAT_PCM_16_BIT_OFFLOAD ? 通道就是两个耳机有不同的声音？？一般有单通道(mono) 双通道(stereo) AudioMixer混音过程参考博客园上的一篇博客[Android] 混音器AudioMixer AUDIOMIXER的创建mNormalFrameCount为输入buffer大小？？mSampleRate为输出采样率123456AudioFlinger::MixerThread::MixerThread(...) : ...&#123; ... mAudioMixer = new AudioMixer(mNormalFrameCount, mSampleRate); ...&#125; 配置参数在MixerThread的prepareTracks_l会对AudioMixer的参数进行配置，如音量，输入源，混音参数等。123456789101112131415161718192021222324252627282930313233343536AudioFlinger::PlaybackThread::mixer_state AudioFlinger::MixerThread::prepareTracks_l(...)&#123; ... // 设置输入源 name是引索集合，track是mActiveTracks？？ mAudioMixer-&gt;setBufferProvider(name, track); // 启用该启用的音轨并更新状态 mAudioMixer-&gt;enable(name); // 设置左右音量 mAudioMixer-&gt;setParameter(name, param, AudioMixer::VOLUME0, &amp;vlf); mAudioMixer-&gt;setParameter(name, param, AudioMixer::VOLUME1, &amp;vrf); mAudioMixer-&gt;setParameter(name, param, AudioMixer::AUXLEVEL, &amp;vaf); // 设置混音格式 mAudioMixer-&gt;setParameter(name,AudioMixer::TRACK,AudioMixer::FORMAT, (void *)track-&gt;format()); // 设置通道数 mAudioMixer-&gt;setParameter(name,AudioMixer::TRACK,AudioMixer::CHANNEL_MASK, (void *)(uintptr_t)track-&gt;channelMask()); // ... // 设置采样率 mAudioMixer-&gt;setParameter(name,AudioMixer::RESAMPLE,AudioMixer::SAMPLE_RATE,(void *)(uintptr_t)reqSampleRate); // 设置播放速率 mAudioMixer-&gt;setParameter(name,AudioMixer::TIMESTRETCH,AudioMixer::PLAYBACK_RATE,&amp;playbackRate); // ... // mark一下 if (mMixerBufferEnabled &amp;&amp; (track-&gt;mainBuffer() == mSinkBuffer || track-&gt;mainBuffer() == mMixerBuffer)) &#123; mAudioMixer-&gt;setParameter(name,AudioMixer::TRACK,AudioMixer::MIXER_FORMAT, (void *)mMixerBufferFormat); &#125; // 设置输出 mAudioMixer-&gt;setParameter(name,AudioMixer::TRACK,AudioMixer::MAIN_BUFFER, (void *)mMixerBuffer); // ...&#125; 混音函数选择先计算track的flags，然后通过flags来判断要混音的函数1234567891011121314151617181920212223242526272829303132333435363738394041void AudioMixer::process__validate(state_t* state, int64_t pts)&#123; ...(计算需要invalidate的track) // 主要通过下列几个参数去判断 bool all16BitsStereoNoResample = true; bool resampling = false; bool volumeRamp = false; uint32_t en = state-&gt;enabledTracks; while (en) &#123; //对所有需要进行混音的track const int i = 31 - __builtin_clz(en); //取出最高位为1的bit en &amp;= ~(1&lt;&lt;i); //把这一位置为0 countActiveTracks++; track_t&amp; t = state-&gt;tracks[i]; //取出来track // 计算flags uint32_t n = 0; n |= NEEDS_CHANNEL_1 + t.channelCount - 1; //至少有一个channel需要混音 n |= NEEDS_FORMAT_16; //必须为16bit PCM n |= t.doesResample() ? NEEDS_RESAMPLE_ENABLED : NEEDS_RESAMPLE_DISABLED; //是否需要重采样 if (t.auxLevel != 0 &amp;&amp; t.auxBuffer != NULL) &#123; n |= NEEDS_AUX_ENABLED; &#125; if (t.volumeInc[0]|t.volumeInc[1]) &#123; volumeRamp = true; &#125; else if (!t.doesResample() &amp;&amp; t.volumeRL == 0) &#123; n |= NEEDS_MUTE_ENABLED; &#125; t.needs = n; //更新track flag // ...(通过flags选择混音函数) //这里调用一次进行混音，后续会在MixerThread的threadLoop_mix内调用 state-&gt;hook(state, pts); // ... &#125;&#125; 混音就是像搓面把几根面搓成一团 在android里使用process_xxx函数来实现，几个方法大同小异(不是我说的),举个process__genericResampling当例子。12345678910111213141516171819202122232425262728293031323334// generic code with resamplingvoid AudioMixer::process__genericResampling(state_t* state, int64_t pts)&#123; int32_t* const outTemp = state-&gt;outputTemp; size_t numFrames = state-&gt;frameCount; uint32_t e0 = state-&gt;enabledTracks; while (e0) &#123; // ...(选出有相同mainBuffer的track集合e1) int32_t *out = t1.mainBuffer; memset(outTemp, 0, size); // 搓面 while (e1) &#123; const int i = 31 - __builtin_clz(e1); e1 &amp;= ~(1&lt;&lt;i); track_t&amp; t = state-&gt;tracks[i]; int32_t *aux = NULL; if (CC_UNLIKELY(t.needs &amp; NEEDS_AUX)) &#123; aux = t.auxBuffer; &#125; // this is a little goofy, on the resampling case we don't // acquire/release the buffers because it's done by // the resampler. if (t.needs &amp; NEEDS_RESAMPLE) &#123; t.resampler-&gt;setPTS(pts); t.hook(&amp;t, outTemp, numFrames, state-&gt;resampleTemp, aux); &#125; else &#123; //... &#125; &#125; &#125;&#125; 真正的采样在这(最终的采样在resample)123456789101112131415161718192021222324void AudioMixer::track__genericResample(track_t* t, int32_t* out, size_t outFrameCount, int32_t* temp, int32_t* aux)&#123; ALOGVV("track__genericResample\n"); t-&gt;resampler-&gt;setSampleRate(t-&gt;sampleRate); // ramp gain - resample to temp buffer and scale/mix in 2nd step if (aux != NULL) &#123; // ...(设置ramp音量) &#125; else &#123; if (CC_UNLIKELY(t-&gt;volumeInc[0]|t-&gt;volumeInc[1])) &#123; t-&gt;resampler-&gt;setVolume(UNITY_GAIN_FLOAT, UNITY_GAIN_FLOAT); memset(temp, 0, outFrameCount * MAX_NUM_CHANNELS * sizeof(int32_t)); t-&gt;resampler-&gt;resample(temp, outFrameCount, t-&gt;bufferProvider); volumeRampStereo(t, out, outFrameCount, temp, aux); &#125; // constant gain else &#123; t-&gt;resampler-&gt;setVolume(t-&gt;mVolume[0], t-&gt;mVolume[1]); t-&gt;resampler-&gt;resample(out, outFrameCount, t-&gt;bufferProvider); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android_Audio</category>
      </categories>
      <tags>
        <tag>framework</tag>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝牙设备播放流程]]></title>
    <url>%2F2019%2F01%2F19%2FAndroid_Audio%2F%E8%93%9D%E7%89%99%E8%AE%BE%E5%A4%87%E6%92%AD%E6%94%BE%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[因为蓝牙通路与其他设备不同（多了一个蓝牙设备），因此播放的流程也与其他设备略有不同。 蓝牙设备的连接从setDeviceConnectionState开始,AudioPolicyManager先注册Device后，再去打开设备对应的output，如果是duplicating类型的话，还要建一个DuplicateOutput，关联该output与mPrimaryOutput 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//---&gt;frameworks/av/services/audiopolicy/managerdefault/AudioPolicyManager.cppstatus_t AudioPolicyManager::setDeviceConnectionState(audio_devices_t device, audio_policy_dev_state_t state, const char *device_address, const char *device_name)&#123; return setDeviceConnectionStateInt(device, state, device_address, device_name);&#125;status_t AudioPolicyManager::setDeviceConnectionStateInt(audio_devices_t device, audio_policy_dev_state_t state, const char *device_address, const char *device_name)&#123; // ... sp&lt;DeviceDescriptor&gt; devDesc = mHwModules.getDeviceDescriptor(device, device_address, device_name); // ... // handle output devices // ... SortedVector &lt;audio_io_handle_t&gt; outputs; ssize_t index = mAvailableOutputDevices.indexOf(devDesc); mPreviousOutputs = mOutputs; // ...(注册设备) if (index &gt;= 0) &#123; sp&lt;HwModule&gt; module = mHwModules.getModuleForDevice(device); if (module == 0) &#123; mAvailableOutputDevices.remove(devDesc); return INVALID_OPERATION; &#125; mAvailableOutputDevices[index]-&gt;attach(module); &#125; else &#123; return NO_MEMORY; &#125; if (checkOutputsForDevice(devDesc, state, outputs, devDesc-&gt;mAddress) != NO_ERROR) &#123; mAvailableOutputDevices.remove(devDesc); return INVALID_OPERATION; &#125; // ...&#125;status_t AudioPolicyManager::checkOutputsForDevice(const sp&lt;DeviceDescriptor&gt; devDesc, audio_policy_dev_state_t state, SortedVector&lt;audio_io_handle_t&gt;&amp; outputs, const String8 address)&#123; // ... // 打开设备所对应的output for (ssize_t profile_index = 0; profile_index &lt; (ssize_t)profiles.size(); profile_index++) &#123; sp&lt;IOProfile&gt; profile = profiles[profile_index]; ... status_t status = mpClientInterface-&gt;openOutput(profile-&gt;getModuleHandle(), &amp;output, &amp;config, &amp;desc-&gt;mDevice, address, &amp;desc-&gt;mLatency, desc-&gt;mFlags); &#125; // ... // 后续处理 if (output != AUDIO_IO_HANDLE_NONE) &#123; addOutput(output, desc); ... else if (((desc-&gt;mFlags &amp; AUDIO_OUTPUT_FLAG_DIRECT) == 0) &amp;&amp; hasPrimaryOutput()) &#123; // ... // open a duplicating output thread for the new output and the primary output duplicatedOutput = mpClientInterface-&gt;openDuplicateOutput(output, mPrimaryOutput-&gt;mIoHandle); // ... &#125; &#125;&#125; openOutput的流程跟其他Output的流程是一样的，最终在AudioFlinger建立了对应Output的Thread。DuplicateOutput使用openDuplicateOutput来打开，最终也是在AudioFlinger建立一个DuplicatingThread。1234567891011121314151617181920212223242526272829303132333435363738394041//---&gt;frameworks/av/services/audiopolicy/service/AudioPolicyClientImpl.cpp// AudioPolicyService的转发audio_io_handle_t AudioPolicyService::AudioPolicyClient::openDuplicateOutput( audio_io_handle_t output1, audio_io_handle_t output2)&#123; sp&lt;IAudioFlinger&gt; af = AudioSystem::get_audio_flinger(); if (af == 0) &#123; ALOGW("%s: could not get AudioFlinger", __func__); return 0; &#125; return af-&gt;openDuplicateOutput(output1, output2);&#125;//---&gt;frameworks/av/services/audioflinger/AudioFlinger.cppaudio_io_handle_t AudioFlinger::openDuplicateOutput(audio_io_handle_t output1, audio_io_handle_t output2)&#123; // 这里两个output对应的thread都是MixerThread，意味着DuplicatingThread对应的线程是MixerThread？？ Mutex::Autolock _l(mLock); MixerThread *thread1 = checkMixerThread_l(output1); MixerThread *thread2 = checkMixerThread_l(output2); // ... audio_io_handle_t id = nextUniqueId(); DuplicatingThread *thread = new DuplicatingThread(this, thread1, id, mSystemReady); thread-&gt;addOutputTrack(thread2); mPlaybackThreads.add(id, thread); thread-&gt;ioConfigChanged(AUDIO_OUTPUT_OPENED); return id;&#125;//---&gt;frameworks/av/services/audioflinger/Threads.cpp AudioFlinger::DuplicatingThread::DuplicatingThread(const sp&lt;AudioFlinger&gt;&amp; audioFlinger, AudioFlinger::MixerThread* mainThread, audio_io_handle_t id, bool systemReady) : MixerThread(audioFlinger, mainThread-&gt;getOutput(), id, mainThread-&gt;outDevice(), systemReady, DUPLICATING), mWaitTimeMs(UINT_MAX)&#123; addOutputTrack(mainThread);&#125; DuplicatingThread的addOutputTrack会创建对应thread的track(也就是生产者啦)12345678910111213141516171819//---&gt;frameworks/av/services/audioflinger/Threads.cpp void AudioFlinger::DuplicatingThread::addOutputTrack(MixerThread *thread)&#123; Mutex::Autolock _l(mLock); // The downstream MixerThread consumes thread-&gt;frameCount() amount of frames per mix pass. // Adjust for thread-&gt;sampleRate() to determine minimum buffer frame count. // Then triple buffer because Threads do not run synchronously and may not be clock locked. const size_t frameCount = 3 * sourceFramesNeeded(mSampleRate, thread-&gt;frameCount(), thread-&gt;sampleRate()); sp&lt;OutputTrack&gt; outputTrack = new OutputTrack(thread, this, mSampleRate, mFormat, mChannelMask, frameCount, IPCThreadState::self()-&gt;getCallingUid()); // ...&#125; DuplicatingThread播放普通的连蓝牙播放（音乐，触屏音等）还不会用到DuplicatingThread，只有在需要双设备播放的情况下（如闹铃，来电等），才会用到DuplicatingThread。DuplicatingThread跟别的PlaybackThread一样，也有prepareTrack_l和mix，就是write的时候不大一样。123456789ssize_t AudioFlinger::DuplicatingThread::threadLoop_write()&#123; // 对每个Tracks写数据 这里DuplicatingThread相当于生产者了 for (size_t i = 0; i &lt; outputTracks.size(); i++) &#123; outputTracks[i]-&gt;write(mSinkBuffer, writeFrames); &#125; mStandby = false; return (ssize_t)mSinkBufferSize;&#125; OutputThrack与AudioTrack类似，也是用obtainBuffer与releaseBuffer来驱动PlaybackThread1234567891011121314bool AudioFlinger::PlaybackThread::OutputTrack::write(void* data, uint32_t frames)&#123; // ... while (waitTimeLeftMs) &#123; // ... status_t status = obtainBuffer(&amp;mOutBuffer, waitTimeLeftMs); // ... memcpy(mOutBuffer.raw, pInBuffer-&gt;raw, outFrames * mFrameSize); // ... mClientProxy-&gt;releaseBuffer(&amp;buf); &#125; // ...&#125; DuplicatingThread作用很明了，就是把一个output的流dup到其他output，这个一开始看名字就看出来了，就是不知道关联的是那个output，驱动其他两个thread的方式。]]></content>
      <categories>
        <category>Android_Audio</category>
      </categories>
      <tags>
        <tag>framework</tag>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charlotte]]></title>
    <url>%2F2019%2F01%2F19%2F%E5%8A%A8%E6%BC%AB%2FCharlotte%2F</url>
    <content type="text"><![CDATA[好久没看到好一点的动漫了，感觉自己是要渐渐脱宅的节奏啊。昨天看完后有好多感想，老想写个post出来，到今天就基本上情节都忘光了，唉~不过总体来讲还是很不错的，主要是没什么讨厌的角色，也没什么虐心的剧情，结局也挺happy，看完没什么感觉但就觉得还可以的动漫（感觉跟凉宫一样类型的）]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的开始]]></title>
    <url>%2F2019%2F01%2F19%2F%E8%AE%B0%E4%BA%8B%2F%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[刚从盒子离职，刚毕业就换了很多份工作，换到自己心都累了。 在很无奈的时候，时时会想起在大学的日子，悠闲到腐烂的生活，也许那就是我理想中的生活吧。 其实我挺珍惜那段时光的，但挽留不住，所以才会最后默默的流泪离开。]]></content>
      <categories>
        <category>记事</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Audio的播放流程]]></title>
    <url>%2F2019%2F01%2F12%2FAndroid_Audio%2FAudio%E7%9A%84%E6%92%AD%E6%94%BE%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[cover 这是基于Android5.1分析的，前几版本好像有些不同，6.0没改太多，不过大体思想是一致的 播放就像个排水机，AuidoPolicyService是阀门，AudioFlinger是排水池，PlaybackThread是发动机，Track是源，AudioOutput是排水孔。AudioTrack是水桶 排水首先要凿个孔（openOutput），然后添加发动机（建立PlaybackThread），然后将源接到水桶上（建立Track），选择排水孔（selectOutput），开启相应的发动机（PlaybackThread从睡眠中唤醒），然后就开始播放（排水）了。。。。 AudioTrack服务端的启动及准备服务端的指的是AudioFlinger跟AudioPolicyService等音频相关的服务，这些服务会在系统开机的时候启动在系统启动完成后，客户端（一般都是app）就能利用这些服务来使用系统提供的功能 AUDIO相关的服务启动开机时系统启动各种服务，AudioFlinger跟AudioPolicyService和一些音频相关的服务会在此启动。各服务的Instantiate()函数在BinderService.h中定义实现，主要是用于抽象出注册服务的操作。BinderService是个模板类，服务继承该类后可以直接注册到systemserver。12345678910111213141516171819202122232425262728//---&gt;frameworks/av/media/mediaserver/main_mediaserver.cppint main(int argc __unused, char** argv)&#123; // ... AudioFlinger::instantiate(); MediaPlayerService::instantiate(); AudioPolicyService::instantiate(); // ...&#125;//---&gt;frameworks/native/include/binder/BinderService.htemplate&lt;typename SERVICE&gt;class BinderService&#123;public: static status_t publish(bool allowIsolated = false) &#123; sp&lt;IServiceManager&gt; sm(defaultServiceManager()); // 这里用模板生成了具体服务的对象 // new SERVICE()将会调用服务(AudioFlinger，AudioPolicyService等)的构造函数 return sm-&gt;addService( String16(SERVICE::getServiceName()), new SERVICE(), allowIsolated); &#125; // ... static void instantiate() &#123; publish(); &#125; // ...&#125;; AUDIOFLINGER的创建AudioFlinger承担混音工作。（总之很重要啦）AudioFlinger的构造函数主要是对成员变量和调试工具的初始化。onFirstRef一般做进一步的初始化工作，AudioFlinger暂时没有在该函数中做重要的工作。123456789101112131415161718192021222324252627282930//---&gt;frameworks/av/services/audioflinger.cppAudioFlinger::AudioFlinger() : BnAudioFlinger(), mPrimaryHardwareDev(NULL), mAudioHwDevs(NULL), mHardwareStatus(AUDIO_HW_IDLE), mMasterVolume(1.0f), mMasterMute(false), mNextUniqueId(1), mMode(AUDIO_MODE_INVALID), mBtNrecIsOff(false), mIsLowRamDevice(true), mIsDeviceTypeKnown(false), mGlobalEffectEnableTime(0), mPrimaryOutputSampleRate(0)&#123;...#ifdef TEE_SINK ....#endif...&#125;void AudioFlinger::onFirstRef()&#123; Mutex::Autolock _l(mLock); ... mPatchPanel = new PatchPanel(this); mMode = AUDIO_MODE_NORMAL;&#125; AUDIOPOLICYSERVICE的创建AudioPolicyService用于控制音频播放策略（比如插耳机的时候来电用什么设备去播放音乐）、管理音频设备等 AudioPolicyService的构造函数更简单，只是初始化主要成员。AudioPolicyService会在onFristRef中做比较多的工作，比如创建command线程，初始化重要成员mAudioPolicyManager。12345678910111213141516171819202122232425262728//---&gt;frameworks/av/services/audiopolicy/AudioPolicyService.cppAudioPolicyService::AudioPolicyService() : BnAudioPolicyService(), mpAudioPolicyDev(NULL), mpAudioPolicy(NULL), mAudioPolicyManager(NULL), mAudioPolicyClient(NULL), mPhoneState(AUDIO_MODE_INVALID)&#123;&#125;void AudioPolicyService::onFirstRef()&#123; // ... &#123; Mutex::Autolock _l(mLock); mTonePlaybackThread = new AudioCommandThread(String8("ApmTone"), this); mAudioCommandThread = new AudioCommandThread(String8("ApmAudio"), this); mOutputCommandThread = new AudioCommandThread(String8("ApmOutput"), this);#ifdef USE_LEGACY_AUDIO_POLICY // ...(暂时这宏意义不明)#else mAudioPolicyClient = new AudioPolicyClient(this); mAudioPolicyManager = createAudioPolicyManager(mAudioPolicyClient);#endif &#125; // ...(效果相关)&#125; AUDIOPOLICYMANAGER的创建AudioPolicyManager作为音频调度策略的实现，在AudioPolicyService关于音频调度的基本都是直接转发给AudioPolicyManager。（貌似可以重载AudioPolicyManager来改动音频策略的实现,6.0开始可以直接动态选择不同的AudiPolicyManger实现） 在构造函数中，打开了所有能用的音频设备和录音设备，并调用AudioPolicyService创建了相应设备的混音线程。123456789101112131415161718192021222324252627//---&gt;frameworks/av/services/audiopolicy/AudioPolicyManager.cppAudioPolicyManager::AudioPolicyManager(AudioPolicyClientInterface *clientInterface) :mPrimaryOutput((audio_io_handle_t)0), ...&#123; mpClientInterface = clientInterface; .// .. // 加载音频模块 defaultAudioPolicyConfig(); // ... for (size_t i = 0; i &lt; mHwModules.size(); i++) &#123; // ... for (size_t j = 0; j &lt; mHwModules[i]-&gt;mOutputProfiles.size(); j++) &#123; // ... status_t status = mpClientInterface-&gt;openOutput(outProfile-&gt;mModule-&gt;mHandle, // 打开音频设备 &amp;output, &amp;config, &amp;outputDesc-&gt;mDevice, String8(""), &amp;outputDesc-&gt;mLatency, outputDesc-&gt;mFlags); &#125; &#125; // ...(打开录音设备)&#125; mpClientInterface就是AudioPolicyService，AudioPolicyService最终会调用AudioFlinger的openOutput函数。12345678910111213141516//---&gt;frameworks/av/services/audiopolicy/AudioPolicyClientImpl.cppstatus_t AudioPolicyService::AudioPolicyClient::openOutput(audio_module_handle_t module, audio_io_handle_t *output, audio_config_t *config, audio_devices_t *devices, const String8&amp; address, uint32_t *latencyMs, audio_output_flags_t flags)&#123; sp&lt;IAudioFlinger&gt; af = AudioSystem::get_audio_flinger(); if (af == 0) &#123; ALOGW("%s: could not get AudioFlinger", __func__); return PERMISSION_DENIED; &#125; return af-&gt;openOutput(module, output, config, devices, address, latencyMs, flags);&#125; AudioFlinger的openOutput中会针对输出设备的类型创建了一个PlaybackThread。PlaybackThread在AudioFlinger相当重要，相当于音频系统的发动机 PlaybackThread有几种，比较常见有MixerThread，蓝牙耳机设备需要外放（比如ring类型的流需要同时从耳机与喇叭出来）的时候使用DuplicatingThread。1234567891011121314151617181920212223242526272829303132333435363738394041424344//---&gt;frameworks/av/services/audioflinger/AudioFlinger.cppstatus_t AudioFlinger::openOutput(audio_module_handle_t module, audio_io_handle_t *output, audio_config_t *config, audio_devices_t *devices, const String8&amp; address, uint32_t *latencyMs, audio_output_flags_t flags)&#123; // ... sp&lt;PlaybackThread&gt; thread = openOutput_l(module, output, config, *devices, address, flags); // ...&#125;sp&lt;AudioFlinger::PlaybackThread&gt; AudioFlinger::openOutput_l(audio_module_handle_t module, audio_io_handle_t *output, audio_config_t *config, audio_devices_t devices, const String8&amp; address, audio_output_flags_t flags)&#123; // ... status_t status = hwDevHal-&gt;open_output_stream( hwDevHal, *output, devices, flags, config, &amp;outStream, address.string()); // ... // 根据flags 创建相应的thread AudioStreamOut *outputStream = new AudioStreamOut(outHwDev, outStream, flags); PlaybackThread *thread; if (flags &amp; AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) &#123; thread = new OffloadThread(this, outputStream, *output, devices); &#125; else if ((flags &amp; AUDIO_OUTPUT_FLAG_DIRECT) || !isValidPcmSinkFormat(config-&gt;format) || !isValidPcmSinkChannelMask(config-&gt;channel_mask)) &#123; thread = new DirectOutputThread(this, outputStream, *output, devices); &#125; else &#123; thread = new MixerThread(this, outputStream, *output, devices); &#125; // ...&#125; PlaybackThread创建完之后在onFirstRef()中会自己启动起来,并会在threadLoop等待一个AudioTrack的连接。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//---&gt;frameworks/av/services/audioflinger/Threads.cppAudioFlinger::MixerThread::MixerThread(const sp&lt;AudioFlinger&gt;&amp; audioFlinger, AudioStreamOut* output, audio_io_handle_t id, audio_devices_t device, type_t type) : PlaybackThread(audioFlinger, output, id, device, type), mFastMixerFutex(0)&#123; // ...(主要初始化了Mixer)&#125;AudioFlinger::PlaybackThread::PlaybackThread(const sp&lt;AudioFlinger&gt;&amp; audioFlinger, AudioStreamOut* output, audio_io_handle_t id, audio_devices_t device, type_t type) : ThreadBase(audioFlinger, id, device, AUDIO_DEVICE_NONE, type), // ...&#123; // ...(初始化了音量相关的参数和获取输出设备的参数)&#125;// 在此PlaybackThread会跑起来，运行threadLoop()void AudioFlinger::PlaybackThread::onFirstRef()&#123; run(mName, ANDROID_PRIORITY_URGENT_AUDIO);&#125;// threadLoop是整个AudioFlinger的核心，混音的工作在此进行bool AudioFlinger::PlaybackThread::threadLoop()&#123; // ... cacheParameters_l(); // ... checkSilentMode_l(); while (!exitPending()) &#123; // ... processConfigEvents_l(); // ... size_t size = mActiveTracks.size(); for (size_t i = 0; i &lt; size; i++) &#123; sp&lt;Track&gt; t = mActiveTracks[i].promote(); if (t != 0) &#123; mLatchD.mFramesReleased.add(t.get(), t-&gt;mAudioTrackServerProxy-&gt;framesReleased()); &#125; &#125; // ... saveOutputTracks(); // ... threadLoop_standby(); // ... clearOutputTracks(); // ... checkSilentMode_l(); // ... mMixerStatus = prepareTracks_l(&amp;tracksToRemove); // ... // 混音，主要设置AudioMixer的参数 threadLoop_mix(); // ... ssize_t ret = threadLoop_write(); // ... threadLoop_drain(); // ... threadLoop_removeTracks(tracksToRemove); tracksToRemove.clear(); &#125; threadLoop_exit(); // ...&#125; 到此各种线程服务准备完毕，可以播放AudioTrack了 客户端播放AudioTrackAndroid SDK向外提供了MediaPlayer和比较底层的AudioTrack接口，MediaPlayer做一些解码的工作，最终还是会使用到AudioTrack。 AUDIOTRACK的构建调用从app开始，首先是AudioTrack(java)的构造函数,会调用jni的native_setup12345678910111213//---&gt;frameworks/base/media/java/android/media/AudioTrack.java public AudioTrack(AudioAttributes attributes, AudioFormat format, int bufferSizeInBytes, int mode, int sessionId)throws IllegalArgumentException &#123; // ...(参数检查) mStreamType = AudioSystem.STREAM_DEFAULT; int[] session = new int[1]; session[0] = sessionId; // native initialization int initResult = native_setup(new WeakReference&lt;AudioTrack&gt;(this), mAttributes, mSampleRate, mChannels, mAudioFormat, mNativeBufferSizeInBytes, mDataLoadMode, session); // ...&#125; jni对应的函数是android_media_AudioTrack_setup，生成一个AudioTrack(c++)并设置其参数123456789101112131415161718192021222324//---&gt;android/frameworks/base/core/jni/android_media_AudioTrack.cppstatic jint android_media_AudioTrack_setup(JNIEnv *env, jobject thiz, jobject weak_this, jobject jaa, jint sampleRateInHertz, jint javaChannelMask, jint audioFormat, jint buffSizeInBytes, jint memoryMode, jintArray jSession) &#123; // ...(检查参数) sp&lt;AudioTrack&gt; lpTrack = new AudioTrack(); // ... // 看样子很重要 AudioTrackJniStorage* lpJniStorage = new AudioTrackJniStorage(); // 分不同的模式设置track switch (memoryMode) &#123; case MODE_STREAM: status = lpTrack-&gt;set(...); break; case MODE_STATIC: // AudioTrack is using shared memory status = lpTrack-&gt;set(...); break; &#125; // ...(错误处理)&#125; AudioTrack的无参构造函数很简单，主要工作还是放在set里面12345678910111213//---&gt;frameworks/av/media/libmedia/AudioTrack.cppAudioTrack::AudioTrack() : mStatus(NO_INIT), mIsTimed(false), mPreviousPriority(ANDROID_PRIORITY_NORMAL), mPreviousSchedulingGroup(SP_DEFAULT), mPausedPosition(0)&#123; mAttributes.content_type = AUDIO_CONTENT_TYPE_UNKNOWN; mAttributes.usage = AUDIO_USAGE_UNKNOWN; mAttributes.flags = 0x0; strcpy(mAttributes.tags, "");&#125; AudioTrack的set的工作很多，服务端的track其实是在此时建立的。123456789101112131415161718192021222324252627282930//---&gt;frameworks/av/media/libmedia/AudioTrack.cppstatus_t AudioTrack::set( audio_stream_type_t streamType, uint32_t sampleRate, audio_format_t format, audio_channel_mask_t channelMask, size_t frameCount, audio_output_flags_t flags, callback_t cbf, void* user, uint32_t notificationFrames, const sp&lt;IMemory&gt;&amp; sharedBuffer, bool threadCanCallJava, int sessionId, transfer_type transferType, const audio_offload_info_t *offloadInfo, int uid, pid_t pid, const audio_attributes_t* pAttributes)&#123; // ...(设置参数等) if (cbf != NULL) &#123; mAudioTrackThread = new AudioTrackThread(*this, threadCanCallJava); mAudioTrackThread-&gt;run("AudioTrack", ANDROID_PRIORITY_AUDIO, 0 /*stack*/); &#125; status_t status = createTrack_l(); // ...(错误处理)&#125; 这里插入一个track选择output的一个过程,在工作中经常碰到这个鬼东西。在创建track的时候其实音频的路由已经定好了，之前还一直以为在start后选，在createTrack之前，会调用getOutputForAttr来获取当前的流对应的output（后面有空会补一下output跟device及stream的乱七八糟的关系）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//---&gt;frameworks/av/media/libmedia/AudioTrack.cppstatus_t AudioTrack::createTrack_l()&#123; const sp&lt;IAudioFlinger&gt;&amp; audioFlinger = AudioSystem::get_audio_flinger(); // ...(计算FrameCount，Latency等 // 这里的output即到底层的通路，可以用adb shell dumpsys media.audio_policy 看到所有的output status_t status = AudioSystem::getOutputForAttr(attr, &amp;output, (audio_session_t)mSessionId, &amp;streamType, mClientUid, mSampleRate, mFormat, mChannelMask, mFlags, mSelectedDeviceId, mOffloadInfo); sp&lt;IAudioTrack&gt; track = audioFlinger-&gt;createTrack(streamType, //创建服务端的track mSampleRate, format, mChannelMask, &amp;temp, &amp;trackFlags, mSharedBuffer, output, tid, &amp;mSessionId, mClientUid, &amp;status); // ...(debug代码等) // AudioTrackClientProxy主要实现管理cblk和服务端通信 mProxy = new AudioTrackClientProxy(cblk, buffers, frameCount, mFrameSizeAF); // ...&#125;// AudioSystem转发给AudiopolicyService//---&gt;frameworks/av/media/libmedia/AudioSystem.cppstatus_t AudioSystem::getOutputForAttr(const audio_attributes_t *attr, audio_io_handle_t *output, audio_session_t session, audio_stream_type_t *stream, uid_t uid, uint32_t samplingRate, audio_format_t format, audio_channel_mask_t channelMask, audio_output_flags_t flags, audio_port_handle_t selectedDeviceId, const audio_offload_info_t *offloadInfo)&#123; const sp&lt;IAudioPolicyService&gt;&amp; aps = AudioSystem::get_audio_policy_service(); if (aps == 0) return NO_INIT; return aps-&gt;getOutputForAttr(attr, output, session, stream, uid, samplingRate, format, channelMask, flags, selectedDeviceId, offloadInfo);&#125;// AudioPolicyService 转发给AudioPolicyManager//---&gt;/frameworks/av/services/audiopolicy/service/AudioPolicyInterfaceImpl.cppstatus_t AudioPolicyService::getOutputForAttr(const audio_attributes_t *attr, audio_io_handle_t *output, audio_session_t session, audio_stream_type_t *stream, uid_t uid, uint32_t samplingRate, audio_format_t format, audio_channel_mask_t channelMask, audio_output_flags_t flags, audio_port_handle_t selectedDeviceId, const audio_offload_info_t *offloadInfo)&#123; // ... if (IPCThreadState::self()-&gt;getCallingPid() != getpid_cached || uid == (uid_t)-1) &#123; uid_t newclientUid = IPCThreadState::self()-&gt;getCallingUid(); if (uid != (uid_t)-1 &amp;&amp; uid != newclientUid) &#123; ALOGW("%s uid %d tried to pass itself off as %d", __FUNCTION__, newclientUid, uid); &#125; uid = newclientUid; &#125; return mAudioPolicyManager-&gt;getOutputForAttr(attr, output, session, stream, uid, samplingRate, format, channelMask, flags, selectedDeviceId, offloadInfo);&#125;// 这里涉及到了流和策略及output的选择，还是比较重要的吧//---&gt;frameworks/av/services/audiopolicy/managerdefault/AudioPolicyManager.cppstatus_t AudioPolicyManager::getOutputForAttr(const audio_attributes_t *attr, audio_io_handle_t *output, audio_session_t session, audio_stream_type_t *stream, uid_t uid, uint32_t samplingRate, audio_format_t format, audio_channel_mask_t channelMask, audio_output_flags_t flags, audio_port_handle_t selectedDeviceId, const audio_offload_info_t *offloadInfo)&#123; // ...(流类型判断) // 获取路由策略 routing_strategy strategy = (routing_strategy) getStrategyForAttr(&amp;attributes); // 获取策略对应的设备 audio_devices_t device = getDeviceForStrategy(strategy, false /*fromCache*/); // ...(判断flag) // 获取对应设备的output *output = getOutputForDevice(device, session, *stream, samplingRate, format, channelMask, flags, offloadInfo); // ... return NO_ERROR;&#125; 接下来的服务端AudioFlinger会调用PlaybackThread的createTrack_l创建Track。123456789101112131415161718192021222324252627282930//---&gt;frameworks/av/services/audioflinger/AudioFlinger.cppsp&lt;IAudioTrack&gt; AudioFlinger::createTrack( audio_stream_type_t streamType, uint32_t sampleRate, audio_format_t format, audio_channel_mask_t channelMask, size_t *frameCount, IAudioFlinger::track_flags_t *flags, const sp&lt;IMemory&gt;&amp; sharedBuffer, audio_io_handle_t output, pid_t tid, int *sessionId, int clientUid, status_t *status)&#123; // ...(参数检查) // 根据output选择对应的thread PlaybackThread *thread = checkPlaybackThread_l(output); // ... track = thread-&gt;createTrack_l(client, streamType, sampleRate, format, channelMask, frameCount, sharedBuffer, lSessionId, flags, tid, clientUid, &amp;lStatus); // ... // return handle to client trackHandle = new TrackHandle(track);Exit: *status = lStatus; return trackHandle;&#125; PlaybackThread会创建Track的实体对象1234567891011121314151617181920212223242526//---&gt;android/frameworks/av/services/audioflinger/Threads.cppsp&lt;AudioFlinger::PlaybackThread::Track&gt; AudioFlinger::PlaybackThread::createTrack_l( const sp&lt;AudioFlinger::Client&gt;&amp; client, audio_stream_type_t streamType, uint32_t sampleRate, audio_format_t format, audio_channel_mask_t channelMask, size_t *pFrameCount, const sp&lt;IMemory&gt;&amp; sharedBuffer, int sessionId, IAudioFlinger::track_flags_t *flags, pid_t tid, int uid, status_t *status)&#123; // ...(设置参数) if (!isTimed) &#123; track = new Track(this, client, streamType, sampleRate, format, channelMask, frameCount, NULL, sharedBuffer, sessionId, uid, *flags, TrackBase::TYPE_DEFAULT); &#125; else &#123; track = TimedTrack::create(this, client, streamType, sampleRate, format, channelMask, frameCount, sharedBuffer, sessionId, uid); &#125; // ...&#125; (TODO:这样应有Track构建的分析) 到这一步，客户端跟服务端的track都创建好了，就等着播放了。 AUDIOTRACK的播放AudioTrack(java)会调用play进行音频播放的准备。1234567891011121314//---&gt;frameworks/base/media/java/android/media/AudioTrack.javapublic void play()throws IllegalStateException &#123; if (mState != STATE_INITIALIZED) &#123; throw new IllegalStateException("play() called on uninitialized AudioTrack."); &#125; if (isRestricted()) &#123; setVolume(0); &#125; synchronized(mPlayStateLock) &#123; native_start(); mPlayState = PLAYSTATE_PLAYING; &#125;&#125; play()会调用jni的native_start(),对应的函数是android_media_AudioTrack_start(), android_media_AudioTrack_start()只是做了转发，最后会调用 AudioTrack(c++)的start(), AudioTrack的start又会调用TrackHandle(服务端的Track代理) 的start，最后会调用到服务端Track的start。1234567//---&gt;frameworks/av/media/libmedia/AudioTrack.cppstatus_t AudioTrack::start()&#123; ...(标记位和参数的检测) status = mAudioTrack-&gt;start(); ...&#125; TrackHandle仅仅做过转发,最后会触发PlaybackThread的addTrack_l()123456789101112//---&gt;frameworks/av/services/audioflinger/Tracks.cppstatus_t AudioFlinger::TrackHandle::start() &#123; return mTrack-&gt;start();&#125;status_t AudioFlinger::PlaybackThread::Track::start(AudioSystem::sync_event_t event __unused, int triggerSession __unused)&#123; ... status = playbackThread-&gt;addTrack_l(this); ...&#125; PlaybackTread的addTrack_l主要工作是添加track到mActiveTracks,并激活沉睡的PlaybackTread。12345678910111213141516171819202122232425//---&gt;frameworks/av/services/audioflinger/Threads.cppstatus_t AudioFlinger::PlaybackThread::addTrack_l(const sp&lt;Track&gt;&amp; track)&#123; ... mActiveTracks.add(track); ... onAddNewTrack_l();&#125;void AudioFlinger::PlaybackThread::onAddNewTrack_l()&#123; ALOGV("signal playback thread"); broadcast_l();&#125;void AudioFlinger::PlaybackThread::broadcast_l()&#123; // Thread could be blocked waiting for async // so signal it to handle state changes immediately // If threadLoop is currently unlocked a signal of mWaitWorkCV will // be lost so we also flag to prevent it blocking on mWaitWorkCV mSignalPending = true; mWaitWorkCV.broadcast();&#125; 接下来就是写入音频数据 AudioTrack.java会调用write写入音频数据(播放声音)12345//---&gt;frameworks/base/media/java/android/media/AudioTrack.javapublic int write(byte[] audioData, int offsetInBytes, int sizeInBytes) &#123; int ret = native_write_byte(audioData, offsetInBytes, sizeInBytes, mAudioFormat, true /*isBlocking*/);&#125; native_write_byte()会调用jni的android_media_AudioTrack_write_byte，会调用jni的android_media_AudioTrack_write_byte，主要是获取java传下来的数据， 并调用writeToTrack来向共享内存写入数据，writeToTrack又分track是否为stream或static来做不同的处理。12345678910111213141516171819202122232425262728293031323334353637383940//---&gt;android/frameworks/base/core/jni/android_media_AudioTrack.cppstatic jint android_media_AudioTrack_write_byte(JNIEnv *env, jobject thiz, jbyteArray javaAudioData, jint offsetInBytes, jint sizeInBytes, jint javaAudioFormat, jboolean isWriteBlocking)&#123; // ... cAudioData = (jbyte *)env-&gt;GetByteArrayElements(javaAudioData, NULL); // ... jint written = writeToTrack(lpTrack, javaAudioFormat, cAudioData, offsetInBytes, sizeInBytes, isWriteBlocking == JNI_TRUE /* blocking */); // ...&#125;jint writeToTrack(const sp&lt;AudioTrack&gt;&amp; track, jint audioFormat, const jbyte* data, jint offsetInBytes, jint sizeInBytes, bool blocking = true) &#123; if (track-&gt;sharedBuffer() == 0) &#123; written = track-&gt;write(data + offsetInBytes, sizeInBytes, blocking); &#125; else &#123; // ... switch (format) &#123; default: case AUDIO_FORMAT_PCM_FLOAT: case AUDIO_FORMAT_PCM_16_BIT: &#123; // ... memcpy(track-&gt;sharedBuffer()-&gt;pointer(), data + offsetInBytes, sizeInBytes); // ... &#125; break; case AUDIO_FORMAT_PCM_8_BIT: &#123; // ... memcpy_to_i16_from_u8(dst, src, count); // ... &#125; break; &#125; &#125; return written;&#125; 其中stream类型的track会调用AudioTrack(c++)的write,AudioTrack会使用obtainBuffer获取一块共享内存，并写入数据，写完后用releaseBuffer释放共享内存。（就可以给AudioFlingr使用了）123456789101112131415161718192021222324252627282930313233343536//---&gt;frameworks/av/media/libmedia/AudioTrack.cppssize_t AudioTrack::write(const void* buffer, size_t userSize, bool blocking)&#123; // ...(参数检查) while (userSize &gt;= mFrameSize) &#123; audioBuffer.frameCount = userSize / mFrameSize; status_t err = obtainBuffer(&amp;audioBuffer, blocking ? &amp;ClientProxy::kForever : &amp;ClientProxy::kNonBlocking); // ...(错误处理) // ...(memcpy buffer -&gt; audioBuffer); // ...(计算剩余数据) releaseBuffer(&amp;audioBuffer); &#125;&#125;status_t AudioTrack::obtainBuffer(Buffer* audioBuffer, int32_t waitCount)&#123; // ...（参数转换跟计算) return obtainBuffer(audioBuffer, requested);&#125;status_t AudioTrack::obtainBuffer(Buffer* audioBuffer, const struct timespec *requested, struct timespec *elapsed, size_t *nonContig)&#123; // ...（参数转换） status = proxy-&gt;obtainBuffer(&amp;buffer, requested, elapsed); // ...(结果的填充)&#125;void AudioTrack::releaseBuffer(Buffer* audioBuffer)&#123; // ... mProxy-&gt;releaseBuffer(&amp;buffer); // ...&#125; obtainBuffer跟releaseBuffer的具体实现交给了AudioTrackClientProxy来实现，主要是管理cblk对象与共享内存。应该深入研究一下。 服务端读取共享内存的音频数据是在PlaybackThread的threadLoop()中进行的，MixerThread也使用该函数，不过重写了threadLoop_mix()等关键函数(典型的多态)。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//---&gt;frameworks/av/services/audioflinger/Threads.cppbool AudioFlinger::PlaybackThread::threadLoop()&#123; // ... cacheParameters_l(); // ... acquireWakeLock(); // ... checkSilentMode_l(); while (!exitPending())&#123; // ...(lock) processConfigEvents_l(); // ... saveOutputTracks(); // ...(wakelock wait,not understand,**mark**) // ... threadLoop_standby(); // 准备音频设备?? // ...(参数检测) prepareTracks_l(&amp;tracksToRemove); // ... if (mBytesRemaining == 0) &#123; mCurrentWriteLength = 0; if (mMixerStatus == MIXER_TRACKS_READY) &#123; // threadLoop_mix() sets mCurrentWriteLength threadLoop_mix(); // 混音 &#125; // ...(其他情况处理) // ...(音效处理) &#125; if (mBytesRemaining) &#123; ssize_t ret = threadLoop_write(); // 写到音频设备 if (ret &lt; 0) &#123; mBytesRemaining = 0; &#125; else &#123; mBytesWritten += ret; mBytesRemaining -= ret; &#125; &#125; // ...(其他情况处理) // 播放完成，删除已经播放的tracks threadLoop_removeTracks(tracksToRemove); tracksToRemove.clear(); clearOutputTracks(); effectChains.clear(); &#125; threadLoop_exit(); //... releaseWakeLock(); mWakeLockUids.clear(); mActiveTracksGeneration++;&#125; 这里重点看一下 MixerThread的threadLoop_mix 和 threadLoop_writethreadLoop_mix调用了AudioMixer的process,threadLoop_write最终调用mOutput-&gt;stream-&gt;write写到驱动里去了12345678910111213141516171819202122//---&gt;frameworks/av/services/audioflinger/Threads.cppvoid AudioFlinger::MixerThread::threadLoop_mix()&#123; // ... // mix buffers... mAudioMixer-&gt;process(pts); // ...&#125;ssize_t AudioFlinger::MixerThread::threadLoop_write()&#123; // ...(处理一些fastmix的情况) return PlaybackThread::threadLoop_write();&#125;ssize_t AudioFlinger::PlaybackThread::threadLoop_write()&#123; // ...(一些Sink操作) bytesWritten = mOutput-&gt;stream-&gt;write(mOutput-&gt;stream, (char *)mSinkBuffer + offset, mBytesRemaining); // ...&#125; AudioMixer的process是一个hook函数，根据不同的情况会调用不同的函数。具体的调用会调用到AudioMixer中以process开头的一组函数。如 void AudioMixer::process__validate(state_t* state, int64_t pts) void AudioMixer::process__nop(state_t* state, int64_t pts) void AudioMixer::process__genericNoResampling(state_t* state, int64_t pts) void AudioMixer::process__genericResampling(state_t* state, int64_t pts) void AudioMixer::process__OneTrack16BitsStereoNoResampling(state_t* state,int64_t pts) void AudioMixer::process__OneTrack24BitsStereoNoResampling(state_t* state,int64_t pts) void AudioMixer::process_NoResampleOneTrack(state_t* state, int64_t pts) 这里以process__OneTrack16BitsStereoNoResampling为例子,在获取buffer的时候使用了Track的getNextBuffer和releaseBuffer。123456789101112131415161718192021222324252627//---&gt;frameworks/av/services/audioflinger/AudioMixer.cppvoid AudioMixer::process(int64_t pts)&#123; mState.hook(&amp;mState, pts);&#125;void AudioMixer::process__OneTrack16BitsStereoNoResampling(state_t* state, int64_t pts)&#123; const int i = 31 - __builtin_clz(state-&gt;enabledTracks); const track_t&amp; t = state-&gt;tracks[i]; AudioBufferProvider::Buffer&amp; b(t.buffer); // ...(音量设置) while (numFrames) &#123; // ...(Frame的计算) t.bufferProvider-&gt;getNextBuffer(&amp;b, outputPTS); // 获取客户端写入的buffer // ...(错误处理) // 混音 switch (t.mMixerFormat) &#123; case AUDIO_FORMAT_PCM_FLOAT: ... break; case AUDIO_FORMAT_PCM_16_BIT: ... break; default:LOG_ALWAYS_FATAL("bad mixer format: %d", t.mMixerFormat); &#125; // ... t.bufferProvider-&gt;releaseBuffer(&amp;b);&#125; 其他问题这里只是简单的过了一下AudioTrack播放音频的流程，其他的地方还有很多东西要看。 共享内存的同步(AudioTrackClientProxy的obtainBuffer和releaseBuffer*和bufferProvider的getNextBuffer和releaseBuffer); mOutput-&gt;stream-&gt;write最终的去向。 AudioPolicyService的一些音频策略 上层的Mediaplayer的一些工作]]></content>
      <categories>
        <category>Android_Audio</category>
      </categories>
      <tags>
        <tag>framework</tag>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android diplay的学习]]></title>
    <url>%2F2019%2F01%2F12%2FAndroid_Graphics%2Fandroid-diplay%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[android display系统还是很复杂的， 上层View系统 绘制（MainThread ThreadedRender） 叠合（SurfaceFlinger） 显示（hw层）]]></content>
      <categories>
        <category>Android_Graphics</category>
      </categories>
      <tags>
        <tag>framework</tag>
        <tag>graphics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[google tracing的研究]]></title>
    <url>%2F2019%2F01%2F12%2FAndroid%2Ftracing%E7%9A%84%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[最近使用systrace做性能测试，在systrace上统计红绿灯，因为数到眼残，所以做了个自动数帧的工具。主要做法是修改chrome tracing的源码 话说tracing这么好用，不出个cmdline真不合理。 tracing on github 幸运的看到了一段代码12/*./tracing/tracing/extras/android/android_auditor.html*/pushFramesAndJudgeJank_: function() 一看就知道是在判断帧的状态然后就加了统计代码12345678910111213141516171819var redFrame = 0;var yellowFrame = 0;var greenFrame = 0;app.process.frames.forEach(function(frame) &#123; if (frame.totalDuration &gt; EXPECTED_FRAME_TIME_MS * 2) &#123; // 红帧 badFramesObserved += 2; frame.perfClass = FRAME_PERF_CLASS.TERRIBLE redFrame += 1; &#125; else if (frame.totalDuration &gt; EXPECTED_FRAME_TIME_MS || frameMissedDeadline(frame)) &#123; // 黄帧 badFramesObserved++; frame.perfClass = FRAME_PERF_CLASS.BAD; yellowFrame += 1; &#125; else &#123; // 绿帧 frame.perfClass = FRAME_PERF_CLASS.GOOD; greenFrame += 1; &#125;&#125;); 最后用log输出1console.log("%d %d %d",redFrame,yellowFrame,greenFrame); 后面又要搞自动化，就是吧js里面的东西打出来有四个思路 用nodejs运行，将结果写文件 html5写文件 重定向log 建本地服务器，用post提交数据 nodejs的很简单，下了node-webkit的源码，然后建了个helloword的工程，发现打不开，突然就想到tracing这个东西跟chrome有很强关系，于是用火狐打开trace2html生成的html发现打不开，应该就是只有chrome能解析systrace的数据 html5的没怎么尝试，因为写文件会写到chrome的安装目录上的，无法写到html文件所在的目录（安全机制，这个限制是必须的），即使写出来用法也很奇怪 建本地服务器，这个应该是可以的，感觉就复杂了点，而且流程太多也不好，容易出bug 重定向一开始以为没希望，到google查了一下还真有这个用法用下面的命令可以将许多log包括控制台的log输出到错误输出流上1google-chrome --enable-logging=stderr 很奇葩的是错误输出流的重定向好像有点问题象如下的代码就输出不了，以后还得研究下，1google-chrome --enable-logging=stderr $1 2&gt;&amp;1 | grep &quot;\[Frame\]&quot; &gt; log 后来用nodejs移植了tracing,主要用了vm.runInThisContext,来运行tracing的各个模块,nodejs和javascript有好多不兼容多东西,坑死了. 改代码时用到的正则，匹配html中的js代码123sed -n '/&lt;script */,/&lt;\/script&gt;/p' base/base.js sed -e 'a#"progressMeter.update"#"&#125;"#g' \ -e 'i#"progressMeter.update"#"if(tr.silent == false) &#123;"#g' \ -e 's#"progressMeter.update"#"console.log"#g' tracing/importer/import.js trace抓下来的数据是压缩过的，用下面命令可解压1zlib-flate -uncompress &lt; trace &gt;out 发现了一个极好多正则表达式1echo &quot;asdfkjasldjkf\&quot;shiner\&quot;df&quot; | sed &apos;s/\(.*\)&quot;\(.*\)&quot;\(.*\)/\2/g&apos; 开始port到windows上了,用的还是nodejs因为用到的同步执行命令要求node最新版,所以用下面的命令来安装最新的工具1curl --silent --location https://deb.nodesource.com/setup_0.12 | sudo bash - 自动化打包的功能，先了解先 Node.js - Zip/Unzip a folder windows的cmd太难用了]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[surfaceflinger学习--Binder原理]]></title>
    <url>%2F2019%2F01%2F12%2FAndroid_Graphics%2FSurfaceFlinger%E5%AD%A6%E4%B9%A0-Binder%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[要对系统框架有个大概的了解，再去看这些东西比较好，参考：《老罗android之旅分析android源码》《深入理解Android》 SurfaceFlinger作为android绘制服务，涉及东西还是挺多的。 跨进程通信Binder机制 上层的View系统 下层的Display系统 Binder，Binder主要用于Android中的跨进程通信，类似与socket一样的东西，由于Android将Bindder分为了业务层与传输层，导致了一堆Bindder对象的出现，再加上有一个比较特殊的服务ServiceManager一部分使用了Bindder，一部分又没有有使用Bindder，还有什么Server跟Service，导致看的整个人都不好。 BpBinder与BBinder是一对，用于传输层的通信BpSerivce与BnSerivce是一对，用于业务层的通信ISerivce是客户端使用的Serivce接口Serivce是具体的实现 最终的通信发生在IPCThreadState，具体实现使用/dev/binder这个设备文件及使用ioctl来与驱动通信。 举个荔枝 SurfaceFlinger与Ap通信是通过Binder来通信的，而且还不仅仅是一种，反正先关注ISurfaceComposerClient 除了个别名称不一致，其他都与之前分析的IBinder架构是一致的 分别来看一下其中每个类 ISurfaceComposerClientISurfaceComposerClient在ISurfaceComposerClient.h中定义具体内容就是几个接口的声明 1234567891011121314class ISurfaceComposerClient : public IInterface&#123;public: DECLARE_META_INTERFACE(SurfaceComposerClient); ... virtual status_t createSurface( const String8&amp; name, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp) = 0; virtual status_t destroySurface(const sp&lt;IBinder&gt;&amp; handle) = 0; virtual status_t clearLayerFrameStats(const sp&lt;IBinder&gt;&amp; handle) const = 0; virtual status_t getLayerFrameStats(const sp&lt;IBinder&gt;&amp; handle, FrameStats* outStats) const = 0;&#125;; BpSurfaceComposerClientBpSurfaceComposerClinet在ISurfaceComposerClient.cpp定义与实现123456789101112131415161718192021222324252627282930class BpSurfaceComposerClient : public BpInterface&lt;ISurfaceComposerClient&gt;&#123;public: BpSurfaceComposerClient(const sp&lt;IBinder&gt;&amp; impl) : BpInterface&lt;ISurfaceComposerClient&gt;(impl) &#123; &#125; virtual status_t createSurface(const String8&amp; name, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp) &#123; // 打包参数 Parcel data, reply; data.writeInterfaceToken(ISurfaceComposerClient::getInterfaceDescriptor()); data.writeString8(name); data.writeInt32(w); data.writeInt32(h); data.writeInt32(format); data.writeInt32(flags); // 用IBinder的transact，开始通信层的通信 remote()-&gt;transact(CREATE_SURFACE, data, &amp;reply); // 接收结果 *handle = reply.readStrongBinder(); *gbp = interface_cast&lt;IGraphicBufferProducer&gt;(reply.readStrongBinder()); return reply.readInt32(); &#125; ...(其他在ISurfaceComposerClient定义的借口)&#125;; BnSurfaceComposerClientBnSurfaceComposerClient分别在ISurfaceComposerClient.h和ISurfaceComposerClient.cpp定义，因为服务端的Client类需要继承自BnSurfaceComposerClient，BnSurfaceComposerClient需要被导出。 BnSurfaceComposerClient的定义，只有一个onTransact函数1234class BnSurfaceComposerClient: public BnInterface&lt;ISurfaceComposerClient&gt; &#123; public: virtual status_t onTransact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0); &#125;; BnSurfaceComposerClient的实现1234567891011121314151617181920212223242526272829status_t BnSurfaceComposerClient::onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; switch(code) &#123; case CREATE_SURFACE: &#123; CHECK_INTERFACE(ISurfaceComposerClient, data, reply); // 读取参数 String8 name = data.readString8(); uint32_t w = data.readInt32(); uint32_t h = data.readInt32(); PixelFormat format = data.readInt32(); uint32_t flags = data.readInt32(); sp&lt;IBinder&gt; handle; sp&lt;IGraphicBufferProducer&gt; gbp; // 这个是虚函数，运行时会调用子类具体实现的函数 status_t result = createSurface(name, w, h, format, flags, &amp;handle, &amp;gbp); // 打包返回值 reply-&gt;writeStrongBinder(handle); reply-&gt;writeStrongBinder(gbp-&gt;asBinder()); reply-&gt;writeInt32(result); return NO_ERROR; &#125; break; // ...（其他ISurfaceComposerClient中接口对应的信息处理) &#125;&#125; 再看通信层的 BpBinderBpBinder在BpBinder.h与BpBinder.cpp 定义与实现 由于通信关键只跟transact有关，这里先只贴transact相关的代码 BpBinder的定义12345678class BpBinder : public IBinder &#123; public: // ...(一些binder状态查询函数) virtual status_t transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0); // ...(一些binder连接管理函数) // ...(一些锁机制)&#125;; BpBinder的实现1234567891011status_t BpBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags) &#123; // Once a binder has died, it will never come back to life. if (mAlive) &#123; // 这里可以看到将工作委托给了IPCThreadState status_t status = IPCThreadState::self()-&gt;transact( mHandle, code, data, reply, flags); if (status == DEAD_OBJECT) mAlive = 0; return status; &#125; return DEAD_OBJECT;&#125; BBinderBBinder定义123456789101112131415161718class BBinder : public IBinder&#123;public: ...(一些binder状态查询函数) // 这个函数会被IPCThreadState所调用，并调用onTransact函数 virtual status_t transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0); ...(一些binder的操作)protected: // 会被子类实现所覆盖 virtual status_t onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0); ...(一些乱七八糟的东西)&#125;; BBinder实现，主要是transact函数1234567891011121314status_t BBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; data.setDataPosition(0); status_t err = NO_ERROR; switch (code) &#123; // ...（其他情况) default: // 将会调用子类的onTransact err = onTransact(code, data, reply, flags); break; &#125; // ...&#125; Binder层的通信差不多就这样，按这种思路的话下层应该有一个类似listener的东西，当BpBinder做transact的时候，会通知并调用到BBinder的onTransact函数。 IPCThreadState这一层应该是通信层的真正的实现，涉及到线程与驱动 简单起见，只分析跟transact有关的代码 IPCThreadState—客户端123456789101112status_t IPCThreadState::transact(int32_t handle, uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; // ...(参数检查及打印日志) err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL); // ...(各种乱七八糟的东西) err = waitForResponse(reply); // ...(参数检查及打印日志) return err;&#125; writeTransactionData仅仅是填充数据到mOut1234567891011status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags, int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)&#123; binder_transaction_data tr; // ...(初始化tr) // ...(根据data填充tr) mOut.writeInt32(cmd); mOut.write(&amp;tr, sizeof(tr)); return NO_ERROR;&#125; waitForResponse发起了请求并等待驱动返回12345678910111213141516171819202122status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; int32_t cmd; while (1) &#123; talkWithDriver(); // ...(检查返回) cmd = mIn.readInt32(); switch (cmd) &#123; // ...(各种错误情况处理处理) case BR_REPLY: // ...(各种对reply的处理) break; default: err = executeCommand(cmd); // ！！这里是服务端使用的 break; &#125; &#125; // ...(错误处理） return err;&#125; talkWithDriver与驱动通信1234567status_t IPCThreadState::talkWithDriver(bool doReceive)&#123; // ...(初始化bwr) ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr); // ...(错误处理) return err;&#125; IPCThreadState—-服务端服务端在注册服务的时候会调用IPCThreadState的两个函数—-startThreadPool与joinThreadPool,应该就是listener的角色吧startThreadPool调到最后还是会调joinThreadPool，所以直接看joinThreadPooljoinThreadPool在IPCThreadState中实现，相当于时刻等待驱动的消息1234567891011void IPCThreadState::joinThreadPool(bool isMain)&#123; // ...(处理一些东西） status_t result; do &#123; // ...(处理一些东西） result = getAndExecuteCommand(); // ...(处理一些东西） &#125; while (result != -ECONNREFUSED &amp;&amp; result != -EBADF); // ...(处理一些东西）&#125; getAndExecuteCommand获取从驱动过来的消息并执行相应的命令12345678910status_t IPCThreadState::getAndExecuteCommand()&#123; status_t result; int32_t cmd; result = talkWithDriver(); // ...(各种判断) result = executeCommand(cmd); // ...(各种处理) return result;&#125; executeCommand用于执行从客户端过来的命令1234567891011121314151617181920status_t IPCThreadState::executeCommand(int32_t cmd)&#123; switch (cmd) &#123; // ...(各种其他操作) case BR_TRANSACTION: &#123; // ...(各种对tr的操作) Parcel reply; sp&lt;BBinder&gt; b((BBinder*)tr.cookie); b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags); // ...(设置reply) sendReply(reply, 0); // ...(各种其他操作) &#125; break; // ...(各种其他操作) &#125; // ...(各种错误处理)&#125;]]></content>
      <categories>
        <category>Android_Graphics</category>
      </categories>
      <tags>
        <tag>framework</tag>
        <tag>graphics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SurfaceFlinger学习--Surface的绘制过程（续）]]></title>
    <url>%2F2019%2F01%2F12%2FAndroid_Graphics%2FSurfaceFlinger%E5%AD%A6%E4%B9%A0-Surface%E7%9A%84%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B%EF%BC%88%E7%BB%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上一篇说到surfaceflinger绘制就没了，因为surfaceflinger的流程太复杂了，有vscny信号，有messagequeue，等等，所以，主要是因为懒啦，所以先分析关于surfaceflinger的核心函数handleMessageRefresh 123456789101112void SurfaceFlinger::handleMessageRefresh() &#123; ATRACE_CALL(); preComposition(); rebuildLayerStacks(); setUpHWComposer();#ifdef QCOM_BSP setUpTiledDr();#endif doDebugFlashRegions(); doComposition(); postComposition();&#125; 主要工作就是合成layer与显示 一个一个来仔细看- - preComposition 判断是否有未完成的绘制1234567891011121314151617void SurfaceFlinger::preComposition()&#123; bool needExtraInvalidate = false; const LayerVector&amp; layers(mDrawingState.layersSortedByZ); const size_t count = layers.size(); // 调用每个layer的onPreComposition 判读是否有未完成的绘制。 for (size_t i=0 ; i&lt;count ; i++) &#123; if (layers[i]-&gt;onPreComposition()) &#123; needExtraInvalidate = true; &#125; &#125; // 没看懂啦~ if (needExtraInvalidate) &#123; signalLayerUpdate(); &#125;&#125; rebuildLayerStacks 重新计算layer需要重绘的区域123456789101112void SurfaceFlinger::rebuildLayerStacks() &#123; // ...(奇怪的宏定义) // rebuild the visible layer list per screen // 对每个屏幕可见的layer进行rebuild // ...(循环每个屏幕) // ...(定义各种变量) // 计算每一个layer的可见区域 SurfaceFlinger::computeVisibleRegions(dpyId, layers,hw-&gt;getLayerStack(), dirtyRegion, opaqueRegion); // ...(设置计算结果)&#125; setUpHWComposer 设置HWComposer123456789101112131415161718192021222324252627282930313233void SurfaceFlinger::setUpHWComposer() &#123; // ...(循环所有屏幕) bool dirty = !mDisplays[dpy]-&gt;getDirtyRegion(false).isEmpty(); bool empty = mDisplays[dpy]-&gt;getVisibleLayersSortedByZ().size() == 0; bool wasEmpty = !mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers; bool mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty); // new hwc HWComposer&amp; hwc(getHwComposer()); if (hwc.initCheck() == NO_ERROR) &#123; // build the h/w work list // ...(不知道在干啥) // set the per-frame data // ...(各种种种) // ...(奇怪的宏定义) // ...(各种获取layer) // 做了一些变换 layer-&gt;setPerFrameData(hw, *cur); // ...（奇怪的宏定义) // If possible, attempt to use the cursor overlay on each display. // ...(不知道在干啥) &#125; status_t err = hwc.prepare(); ALOGE_IF(err, "HWComposer::prepare failed (%s)", strerror(-err)); for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); hw-&gt;prepareFrame(hwc); &#125;&#125; doDebugFlashRegions 绘制调试区域，就是开发者选项–显示surface更新那一闪一闪的东西，可以学习渲染的原理123456789101112131415161718192021222324252627282930313233343536373839void SurfaceFlinger::doDebugFlashRegions()&#123; // is debugging enabled if (CC_LIKELY(!mDebugRegion)) return; const bool repaintEverything = mRepaintEverything; for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; const sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]); if (hw-&gt;isDisplayOn()) &#123; const int32_t height = hw-&gt;getHeight(); RenderEngine&amp; engine(getRenderEngine()); // ...(又是奇怪的宏，直接无视) &#123; // transform the dirty region into this screen's coordinate space const Region dirtyRegion(hw-&gt;getDirtyRegion(repaintEverything)); if (!dirtyRegion.isEmpty()) &#123; // redraw the whole screen doComposeSurfaces(hw, Region(hw-&gt;bounds())); // and draw the dirty region // ...（继续无视) // 注意这里，类似与绘图了 一个Layer有两片buffer，一片用于绘制，一片用于显示，绘制完交换 engine.fillRegionWithColor(dirtyRegion, height, 1, 0, 1, 1); hw-&gt;compositionComplete(); hw-&gt;swapBuffers(getHwComposer()); &#125; &#125; &#125; &#125; // 留意下这个，好像也很重要 postFramebuffer(); // ...(延时??) HWComposer&amp; hwc(getHwComposer()); if (hwc.initCheck() == NO_ERROR) &#123; status_t err = hwc.prepare(); ALOGE_IF(err, "HWComposer::prepare failed (%s)", strerror(-err)); &#125;&#125; 感觉自己越来越懒啦]]></content>
      <categories>
        <category>Android_Graphics</category>
      </categories>
      <tags>
        <tag>framework</tag>
        <tag>graphics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SurfaceFlinger学习--Surface的绘制过程]]></title>
    <url>%2F2019%2F01%2F12%2FAndroid_Graphics%2FSurfaceFlinger%E5%AD%A6%E4%B9%A0-Surface%E7%9A%84%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[今天看到一篇很不错的的关于SurfaceFlinger的文章，主要是看到android源码中有一个简单明了的test，而且还被我编译过了，都不知道的前几个星期看的都是些什么东西- -Android 4.4(KitKat)中的设计模式-Graphics子系统 还是从test开始看起吧test的在工程中的位置:frameworks/native/services/surfaceflinger/tests/resize,用于在屏幕上显示一块色块 12345678910111213141516171819202122232425262728int main(int argc, char** argv)&#123; // set up the thread-pool sp&lt;ProcessState&gt; proc(ProcessState::self()); ProcessState::self()-&gt;startThreadPool(); // 连接到surfaceflinger sp&lt;SurfaceComposerClient&gt; client = new SurfaceComposerClient(); // 创建surface sp&lt;SurfaceControl&gt; surfaceControl = client-&gt;createSurface(String8("resize"),600, 800, PIXEL_FORMAT_RGB_565, 0); sp&lt;Surface&gt; surface = surfaceControl-&gt;getSurface(); // 设置Layer的z轴 SurfaceComposerClient::openGlobalTransaction(); surfaceControl-&gt;setLayer(100000); SurfaceComposerClient::closeGlobalTransaction(); // 操纵Buffer中内容 ANativeWindow_Buffer outBuffer; surface-&gt;lock(&amp;outBuffer, NULL); ssize_t bpr = outBuffer.stride * bytesPerPixel(outBuffer.format); android_memset16((uint16_t*)outBuffer.bits, 0xffff, bpr*outBuffer.height); surface-&gt;unlockAndPost(); IPCThreadState::self()-&gt;joinThreadPool(); return 0;&#125; 连接到surfaceflinger补充一点，ComposerSerivce创建时会调用getSerivce函数，然后再调用defaultServiceManager获取ServiceManager接口IServiceManager，再通过IServiceManager的getService获取到SurfaceFlinger服务的接口，ISurfaceComposer其实就是SurfaceFlinger的代理接口。 创建surface补充：Layer继承至SurfaceFlingerConsumer::ContentsChangedListener,实现了Listener的几个处理函数 onFrameAvailable(const BufferItem&amp; item) onFrameReplaced(const BufferItem&amp; item) onSidebandStreamChanged() 设置Layer的z轴使用openGlobaleTransaction可以将几个事务合并成一个提交,而且是必须的: All composer parameters must be changed within a transactionseveral surfaces can be updated in one transaction, all changes arecommitted at once when the transaction is closed.closeGlobalTransaction() requires an IPC with the server. setLayer调用了SurfaceComposer的setLayer,与SurfaceFlinger的连接有点问题 操纵Buffer中的内容其中BufferQueueProducer在queuebuffer中调用了BufferQueueCore的frameAvailableListener的onFrameAvailable方法，经过了一长串的调用最终会调用到Layer的onFrameAvailable。 下面是分析:看了半天的surface post后消息的传递，重重的继承，各种set，（╯－＿－）╯╧╧先写个大概流程，免得待会忘了首先是consumer的创建 在Layer::onFirstRef()12sp&lt;IGraphicBufferConsumer&gt; consumer;BufferQueue::createBufferQueue(&amp;producer, &amp;consumer); listener的创建 没错，mSurfaceFlingerConsumer就是个listener1mSurfaceFlingerConsumer = new SurfaceFlingerConsumer(consumer, mTextureName); SuffaceFlingerComsumer的构造函数 call call call到了… ConsumerBase::ConsumerBase proxy是ConsumerBase自身的代理1status_t err = mConsumer-&gt;consumerConnect(proxy, controlledByApp); Bp端的调用，Bn端的实现 在BufferQueueConsumer::consumerConnect,在这里做了个转发，而且还在h文件里，搞得cpp文件都没有consumerConnect，我&amp;*&amp;^%!(@123virtual status_t consumerConnect(const sp&lt;IConsumerListener&gt;&amp; consumer,bool controlledByApp) &#123; return connect(consumer, controlledByApp);&#125; connect的实现1mCore-&gt;mConsumerListener = consumerListener; 也就是说1consumerListener == ConsumerBase == SuffaceFlingerComsumer 而下面又有1mSurfaceFlingerConsumer-&gt;setContentsChangedListener(this); 相当于1mCore-&gt;mConsumerListener == layer 所以queue的时候1listener.xxx == layer.onXXX; 从这以后，渲染工作就交给了SurfaceFlinger服务了]]></content>
      <categories>
        <category>Android_Graphics</category>
      </categories>
      <tags>
        <tag>framework</tag>
        <tag>graphics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于应用的优化]]></title>
    <url>%2F2019%2F01%2F12%2FAndroid%2F%E5%85%B3%E4%BA%8E%E5%BA%94%E7%94%A8%E7%9A%84%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[在很久以前就有好多人问我app的优化问题，现在看到坑爹的12306的app，才明白那帮人都是吃屎的。 应用优化的话打算用一个星期来学习吧，感觉应该是没有什么成果，但做一做规划终归是极好的 应用层的话花个两天 系统层的话再花两天 其他的话花个两天 一天休息 好，就先这样吧 应用的性能问题跟多问题有关 cpu gpu 内存 系统绘图 系统事件处理 网络 网络跟太底层的东西不理，着重在系统绘图这一块 相关文章android绘图相关机制: Graphics architecture stackoverflow 腾讯技术沙龙分享: Android应用性能评测调优 丧心病狂的专利: 动终端卡顿的测量方法与装置 视频： 阿里技术沙龙 工具什么的: Performance Profiling Tools 深层探究： 探索Webkit内核(http://blog.csdn.net/cutesource/article/details/8731841) 理解WebKit和Chromium(http://blog.csdn.net/cutesource/article/details/8731841) 老罗的android之旅(http://blog.csdn.net/cutesource/article/details/8731841)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乐理的学习]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%9F%B3%E4%B9%90%2F%E4%B9%90%E7%90%86%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[平时都弹吉他都是看这六线谱弹，感觉就像练武掌握了招式，却没理解精髓，为了达到手里有剑，心中无剑的境界，还是要学习点五线谱啊。 基础从最简单的开始do re mi fa sol la si 就是平时说的1 2 3 4 5 6 7 然后就是开始C大调的C D E F G A B 然后是五线谱五线谱音阶好啦今天就这样，改变要一步一步来 12平均率一个纯8度分为平均12份 原理请看：写给理工科人看的乐理 音程纯8度每两个音之间都是有距离的，每个距离都有名称 1234567891011120.5 小二度1 大二度1.5 小三度2 大三度2.5 纯四度3 三全音3.5 纯五度4 小六度4.5 大六度5 小七度5.5 大七度6 纯八度 五线谱五线谱就是五条线的谱子，从下往上叫作第一线、第二线、第三线、第四线、第五线，其间的空隙也有名称，从下往上叫作第一间，第二间，第三间，第四间（这命名起得太没创意了，应该叫什么世界线，生命线，叫个毛线都比这好记） 算了今天就到这了，明天继续学习五线谱吧，感觉写这个都没时间练琴了 音调五线谱有4个音调，高音G2，中音C3，中音C4，低音F4（- -我也不知道G2 C3是什么东西） 然后是b跟#,分别是降调号跟升调号 还有一堆类似于节拍，休止符，附点符，小节什么的，以后再补上吧]]></content>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看病难啊]]></title>
    <url>%2F2019%2F01%2F12%2F%E8%AE%B0%E4%BA%8B%2F%E7%9C%8B%E7%97%85%E9%9A%BE%E5%95%8A%2F</url>
    <content type="text"><![CDATA[昨天一天上午挂个号，下午去看了一下，明天再来 今天早八点去挂号，没号了，我…￥%……&amp;]]></content>
      <categories>
        <category>记事</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>看病</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于哲学]]></title>
    <url>%2F2019%2F01%2F12%2F%E6%97%A0%E7%97%85%E5%91%BB%E5%90%9F%2F%E5%85%B3%E4%BA%8E%E5%93%B2%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[好久以前老是会想，仰望天空的时候，随着目光的延伸，会不会延伸到宇宙的尽头，也偶尔会想活着的意义是什么，死后人往哪去。主要是小时候怕死，也没叫过人死过，就是本能的怕。后来渐渐长大了，这种问题考虑得也少了，第一知道这种问题想了也没有答案，第二自己也开始忙起来(学业啊什么的)，还有就怕想多了会精神病(本来就觉得自己有些想法挺怪的)。 不过最近看了疯子在左 天才在右，发现里面见解挺有趣的。决定还是去补充一些哲学的知识]]></content>
      <categories>
        <category>无病呻吟</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心理测量者]]></title>
    <url>%2F2019%2F01%2F12%2F%E5%8A%A8%E6%BC%AB%2F%E5%BF%83%E7%90%86%E6%B5%8B%E9%87%8F%E8%80%85%2F</url>
    <content type="text"><![CDATA[今天早上花了5个多小时看老虚的心里测量者，好久没熬夜看动漫了。剧情啊人物啊深度啊都很好，就是设定依然扯淡，妈的一个国家级别的中央机构弄来弄去就那几个人，还有大boss居然被一个头盔扫晕了，躲子弹却躲得那么溜。。 不过还是半神作，讲了一些哲学的东西，突然意识动漫这东西也可以像音乐，绘画一样在于传达一些自己对世界的一些看法。话说老虚的几部动漫的op都很好听 小圆脸:ClariS-Connect(コネクト) fate ubw:aimer-brave shine 心理测量者:凛として时雨-abnormalize (发现ubw并不是老虚的…)]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Robolectric使用记录]]></title>
    <url>%2F2019%2F01%2F12%2FAndroid%2FRobolectric%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[日志输出:1ShadowLog.stream = System.out; // 日志输出]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过反射去获取类的属性]]></title>
    <url>%2F2019%2F01%2F12%2FAndroid%2F%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%8E%BB%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[以前打log喜欢用toString，然后自己重写toString的方法 比如有个类1234567Diamond class Diamod &#123; String color; String size; @Override public String toString() &#123; return "color:" + color + " size:" + size; &#125; &#125; 后来发现属性一多特别麻烦想到反射可以查对于的属性名跟属性值，刚好可以用在这里(没处理异常) 1234567891011@Override public String toString() &#123; // 获取该类的所有属性值域 Field[] fields = this.getClass().getFields(); for(Field field : fields) &#123; // 获取该属性名称与值 log += filed.getName() + filed.get(this); &#125; return log; &#125;getFields public Field[] getFields() throws SecurityException 返回该类或接口所有访问权限为public的属性 但getFields()会把父类的域也打印出来，有时候还是希望父类子类分开 发现有另外一个方法getDeclaredFields()12getDeclaredFields：public Field[] getDeclaredFields() throws SecurityException 返回接口或类定义的所有属性的Fileld对象数组，包括public,protected,default(package),private访问权限的属性，但不包括继承的属性。数组里的元素没有经过排序，也没有特殊的顺序。假如类或接口没有声明属性，或该类代表一个原始的类型(Long等),array class或void，该方法返回一个长度为0的数组。 反射的跟权限访问有关系，跟final，static修饰符有关，具体关系以后在去探究。反射跟继承也有很多问题。有空测一下这东西。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一youtube]]></title>
    <url>%2F2019%2F01%2F12%2FAndroid%2F%E6%AF%8F%E5%A4%A9%E4%B8%80youtube%2F</url>
    <content type="text"><![CDATA[Chrome Custom Tabs 哈哈，听到一个印度银在讲Android开发的东西，印度英语真有趣 一个加强版的webview，可以自动填充，共享cookies，更友好的界面，以及提前加载。 靠，几千年没更新了。。 又是这货Colt McAnlis 传送门 ComponentCallbacks 后台进程在低内存的情况下的自救手段 自己手动指定释放内存的控件 依然Colt McAnlis referenced objects referenced objects可能到导致内存泄漏， 不要在异步回调中使用资源(view)不要在静态对象中使用资源(view)不要在WeekHashmap中使用(view)内存泄漏工具–Allocation Tracker 又是几千年的没更新。。正确使用service还是这货Colt McAnlis 成对使用startservice,stopservice &amp;&amp; bindservice,unbindservice]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>技术学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[repo的强制更新]]></title>
    <url>%2F2019%2F01%2F12%2FAndroid%2Frepo%E7%9A%84%E5%BC%BA%E5%88%B6%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[repo是git仓库管理工具，一般用repo sync去更新代码，实质上是在每个仓库下执行git pull,这样就比较蛋疼了，当你本地有提交的话它会自动帮你merge进去，还装做一切都ok的样子。在被坑了数遍之后，终于发现了这个问题。 彻底的同步服务器代码 12345$ repo sync -d# Remove all working directory (and staged) changes.$ repo forall -c 'git reset --hard' # Clean untracked files$ repo forall -c 'git clean -f -d']]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>repo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在android源码添加项目的正确办法]]></title>
    <url>%2F2018%2F04%2F27%2FAndroid%2F%E5%9C%A8android%E6%BA%90%E7%A0%81%E6%B7%BB%E5%8A%A0%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[源码添加项目的正确办法主要是Android.mk文件 lib版本 1234567891011LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := your-module-nameLOCAL_MODULE_TAGS := optionalLOCAL_MODULE_CLASS := JAVA_LIBRARIESLOCAL_SRC_FILES := $(call all-subdir-java-files)LOCAL_JAVA_LIBRARIES := framework services#LOCAL_SDK_VERSION := current include $(BUILD_JAVA_LIBRARY) apk版本12345678910# Android threekeyLOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE_TAGS := optionalLOCAL_SRC_FILES := $(call all-java-files-under, src)LOCAL_SDK_VERSION := currentLOCAL_PACKAGE_NAME := threekey-testLOCAL_CERTIFICATE := platforminclude $(BUILD_PACKAGE) 路径问题递归所有目录1LOCAL_SRC_FILES := $(call all-subdir-java-files) 指定目录1LOCAL_SRC_FILES := $(call $(src_dirs)) 当前目录1LOCAL_SRC_FILES := $(call all-java-files-under, src) 注册项目具体看google README.txt]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>framework</tag>
      </tags>
  </entry>
</search>
